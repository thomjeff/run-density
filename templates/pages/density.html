{% extends "base.html" %}

{% block title %}Density Analysis{% endblock %}

{% block content %}
<div class="page-header">
    <h2>Density Analysis</h2>
    {% if meta %}
    {% endif %}
</div>


<!-- Segment Density Table -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Segment Analysis</h3>
    <table id="density-table">
        <thead>
            <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Schema</th>
                <th>Active Window</th>
                <th>Peak Density</th>
                <th>LOS</th>
                <th>Peak Rate</th>
                <th>Utilization</th>
                <th>Flag</th>
                <th>Worst Bin</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td colspan="10" class="placeholder">Loading density data...</td>
            </tr>
        </tbody>
    </table>
</div>

<!-- Segment Detail Panel (shows on row click) -->
<div id="segment-detail" style="display: none;">
    <div class="card">
        <h3 id="detail-title">Segment Detail</h3>
        
        <!-- Segment Metrics -->
        <div style="margin: 1.5rem 0; padding: 1rem; background: #f8f9fa; border-radius: 4px;">
            <h4 style="margin-bottom: 0.75rem;">Key Metrics</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                <div>
                    <strong>Peak Density:</strong> <span id="detail-peak-density">—</span>
                </div>
                <div>
                    <strong>Level of Service:</strong> <span id="detail-los-badge">—</span>
                </div>
                <div>
                    <strong>Peak Rate:</strong> <span id="detail-peak-rate">—</span>
                </div>
                <div>
                    <strong>Active Window:</strong> <span id="detail-active">—</span>
                </div>
            </div>
        </div>
        
        <!-- Heatmap -->
        <div id="heatmap-container" style="margin: 1.5rem 0;">
            <h4 style="margin-bottom: 0.75rem;">Density Heatmap</h4>
            <img id="heatmap-image" src="" alt="Density heatmap" style="max-width: 100%; border-radius: 4px;" />
            <div id="heatmap-placeholder" class="placeholder">No heatmap data available for this segment.</div>
        </div>
        
        <!-- Bin-Level Table -->
        <div id="bin-details-container" style="margin: 1.5rem 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h4 style="margin: 0;">Bin-Level Details</h4>
                <!-- LOS Filter -->
                <div>
                    <label for="bin-los-filter" style="font-weight: 500; margin-right: 0.5rem;">Filter by LOS:</label>
                    <select id="bin-los-filter" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem;">
                        <option value="">All LOS</option>
                        <option value="A">A - Free Flow</option>
                        <option value="B">B - Comfortable</option>
                        <option value="C">C - Moderate</option>
                        <option value="D">D - Dense</option>
                        <option value="E">E - Very Dense</option>
                        <option value="F">F - Extremely Dense</option>
                    </select>
                </div>
            </div>
            
            <div id="bin-details-loading" class="placeholder" style="padding: 1rem; text-align: center;">
                Loading bin data...
            </div>
            
            <div id="bin-details-content" style="display: none;">
                <table id="bin-details-table">
                    <thead>
                        <tr>
                            <th class="sortable" data-sort="start_km">KM (START/END)</th>
                            <th class="sortable text-center" data-sort="t_start">TIME (START/END)</th>
                            <th class="sortable text-right" data-sort="density">Density (p/m²)</th>
                            <th class="sortable text-right" data-sort="rate">Rate (vph)</th>
                            <th class="sortable text-center" data-sort="los_class">LOS</th>
                        </tr>
                    </thead>
                    <tbody id="bin-details-table-body">
                        <!-- Populated by JavaScript -->
                    </tbody>
                </table>
                
                <!-- Pagination Controls -->
                <div class="pagination-controls" style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; padding: 1rem 0; border-top: 1px solid #eee;">
                    <div class="pagination-info" style="color: #666; font-size: 0.9rem;">
                        <span id="bin-pagination-info">Showing 0-0 of 0 bins</span>
                    </div>
                    <div class="pagination-buttons" style="display: flex; gap: 0.5rem;">
                        <button id="bin-prev-page" style="padding: 0.5rem 1rem; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;" disabled>Previous</button>
                        <span id="bin-page-numbers"></span>
                        <button id="bin-next-page" style="padding: 0.5rem 1rem; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;" disabled>Next</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Level of Service (LOS) Reference -->
        <div style="margin: 1.5rem 0;">
            <h4 style="margin-bottom: 0.75rem;">Level of Service (LOS) Reference</h4>
            <p style="margin-bottom: 1rem; color: #666; font-size: 0.9rem;">Defined by areal density (ρ) in persons per square meter (p/m²).</p>
            <table>
                <thead>
                    <tr>
                        <th>LOS</th>
                        <th>Density Range (p/m²)</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="badge-los badge-A">A</span></td>
                        <td>0.00 – 0.36</td>
                        <td>Free Flow</td>
                    </tr>
                    <tr>
                        <td><span class="badge-los badge-B">B</span></td>
                        <td>0.36 – 0.54</td>
                        <td>Comfortable</td>
                    </tr>
                    <tr>
                        <td><span class="badge-los badge-C">C</span></td>
                        <td>0.54 – 0.72</td>
                        <td>Moderate</td>
                    </tr>
                    <tr>
                        <td><span class="badge-los badge-D">D</span></td>
                        <td>0.72 – 1.08</td>
                        <td>Dense</td>
                    </tr>
                    <tr>
                        <td><span class="badge-los badge-E">E</span></td>
                        <td>1.08 – 1.63</td>
                        <td>Very Dense</td>
                    </tr>
                    <tr>
                        <td><span class="badge-los badge-F">F</span></td>
                        <td>1.63+</td>
                        <td>Extremely Dense</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_head %}
<style>
    /* Issue #374: Bin details table styling */
    #bin-details-table th.sortable {
        cursor: pointer;
        user-select: none;
        position: relative;
        padding: 0.75rem;
        background: #f8f9fa;
        border-bottom: 2px solid #dee2e6;
        font-weight: 600;
    }
    
    #bin-details-table th.sortable:hover {
        background: #e9ecef;
    }
    
    #bin-details-table th.sortable::after {
        content: ' ↕';
        opacity: 0.5;
        font-size: 0.8em;
    }
    
    #bin-details-table th.sort-asc::after {
        content: ' ↑';
        opacity: 1;
        color: #007bff;
    }
    
    #bin-details-table th.sort-desc::after {
        content: ' ↓';
        opacity: 1;
        color: #007bff;
    }
    
    #bin-details-table td {
        padding: 0.75rem;
        border-bottom: 1px solid #dee2e6;
    }
    
    .text-right {
        text-align: right;
    }
    
    .text-center {
        text-align: center;
    }
    
    .pagination-buttons button:hover:not(:disabled) {
        background: #f8f9fa;
        border-color: #007bff;
    }
    
    .pagination-buttons button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
</style>
{% endblock %}

{% block extra_scripts %}
<!-- LOS Colors from SSOT -->
<script>
    const LOS_COLORS = {{ los_colors | tojson }};
</script>

<script>
    let densityData = [];
    
    // Issue #374: Bin-level details state management
    let allBinDetailsData = [];
    let filteredBinDetailsData = [];
    let currentBinPage = 1;
    const BIN_ROWS_PER_PAGE = 10;
    
    // Issue #374: Segment Analysis table pagination
    let currentSegmentPage = 1;
    const SEGMENT_ROWS_PER_PAGE = 10;
    
    // Load density data on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadDensityData();
        setupBinDetailsEventListeners();
    });
    
    // Issue #286: Format worst bin label (segment · distance · time)
    function formatWorstBinLabel(bin) {
        if (!bin || typeof bin !== 'object') {
            return '—';
        }
        
        // Helper: Pick first available number from keys
        function pickNumber(obj, keys) {
            for (const k of keys) {
                const v = obj[k];
                if (typeof v === 'number' && !isNaN(v)) return v;
                if (typeof v === 'string' && v.trim() && !isNaN(Number(v))) return Number(v);
            }
            return null;
        }
        
        // Helper: Pick first available string from keys
        function pickString(obj, keys) {
            for (const k of keys) {
                const v = obj[k];
                if (typeof v === 'string' && v.trim()) return v.trim();
            }
            return null;
        }
        
        // Helper: Convert ISO or HH:MM to HH:MM format
        function hhmmFromISO(s) {
            if (/^\d{2}:\d{2}$/.test(s)) return s;  // Already HH:MM
            try {
                const d = new Date(s);
                if (isNaN(d.getTime())) return s;
                const hh = String(d.getHours()).padStart(2, '0');
                const mm = String(d.getMinutes()).padStart(2, '0');
                return `${hh}:${mm}`;
            } catch {
                return s;
            }
        }
        
        // Get segment ID
        const segment = pickString(bin, ['segment_id', 'seg_id', 'bin_id']) || '—';
        
        // Get distance in km (prefer km, else convert from meters)
        let dStartKm = pickNumber(bin, ['d_start_km', 'dist_start_km', 'start_km']);
        let dEndKm = pickNumber(bin, ['d_end_km', 'dist_end_km', 'end_km']);
        if (dStartKm == null && dEndKm == null) {
            const dStartM = pickNumber(bin, ['d_start_m', 'dist_start_m', 's0_m']);
            const dEndM = pickNumber(bin, ['d_end_m', 'dist_end_m', 's1_m']);
            if (dStartM != null) dStartKm = dStartM / 1000;
            if (dEndM != null) dEndKm = dEndM / 1000;
        }
        const hasDistances = dStartKm != null && dEndKm != null;
        const distLabel = hasDistances
            ? `${dStartKm.toFixed(3)}–${dEndKm.toFixed(3)} km`
            : '';
        
        // Get time window (prefer ISO, accept HH:MM)
        const tStart = pickString(bin, ['t_start', 't0', 'start_t', 'time']);
        const tEnd = pickString(bin, ['t_end', 't1', 'end_t']);
        let timeLabel = '';
        if (tStart && tEnd) {
            timeLabel = `${hhmmFromISO(tStart)}–${hhmmFromISO(tEnd)}`;
        } else if (tStart && tStart.includes('-')) {
            // Handle time already formatted as "HH:MM-HH:MM" 
            timeLabel = tStart.replace('-', '–');
        }
        
        // Compose: "DISTANCE · TIME" (removed "Worst Bin: " and segment ID)
        let label = '';
        if (distLabel) label += distLabel;
        if (timeLabel) {
            if (label) label += ` · ${timeLabel}`;
            else label = timeLabel;
        }
        
        return label || '—';
    }
    
    function loadDensityData() {
        fetch('/api/density/segments')
            .then(response => response.json())
            .then(data => {
                densityData = data;
                renderDensityTable(data);
            })
            .catch(error => {
                console.error('Error loading density data:', error);
                showDensityError();
            });
    }
    
    function renderDensityTable(segments) {
        const tbody = document.querySelector('#density-table tbody');
        tbody.innerHTML = '';
        
        if (!segments || segments.length === 0) {
            // Issue #361: Show informative message with run_id when artifacts are missing
            const runId = '{{ run_id if run_id else "latest run" }}';
            tbody.innerHTML = `<tr><td colspan="10" class="placeholder">⚠️ No density data available for latest run ID: ${runId}. Check logs.</td></tr>`;
            return;
        }
        
        // Issue #374: Apply pagination to Segment Analysis table
        const totalPages = Math.ceil(segments.length / SEGMENT_ROWS_PER_PAGE);
        const startIndex = (currentSegmentPage - 1) * SEGMENT_ROWS_PER_PAGE;
        const endIndex = Math.min(startIndex + SEGMENT_ROWS_PER_PAGE, segments.length);
        const pageSegments = segments.slice(startIndex, endIndex);
        
        pageSegments.forEach(segment => {
            const row = document.createElement('tr');
            row.style.cursor = 'pointer';
            row.addEventListener('click', () => showSegmentDetail(segment.seg_id));
            
            const losBadge = `<span class="badge-los badge-${segment.worst_los}">${segment.worst_los}</span>`;
            const flaggedIcon = segment.flagged ? '⚠️' : '';
            
            // Issue #286: Format worst bin using new formatter
            // Add segment_id to bin object for proper labeling
            const worstBin = segment.worst_bin ? {...segment.worst_bin, segment_id: segment.seg_id} : null;
            const worstBinLabel = formatWorstBinLabel(worstBin);
            
            row.innerHTML = `
                <td>${segment.seg_id}</td>
                <td>${segment.name}</td>
                <td>${segment.schema}</td>
                <td>${segment.active}</td>
                <td>${segment.peak_density.toFixed(3)}</td>
                <td>${losBadge}</td>
                <td>${segment.peak_rate.toFixed(2)}</td>
                <td>${segment.utilization ? segment.utilization.toFixed(3) : '—'}</td>
                <td>${flaggedIcon}</td>
                <td>${worstBinLabel}</td>
            `;
            
            tbody.appendChild(row);
        });
        
        // Issue #374: Update Segment Analysis pagination
        updateSegmentPagination(totalPages, startIndex, endIndex, segments.length);
    }
    
    // Issue #374: Update Segment Analysis pagination controls
    function updateSegmentPagination(totalPages, startIndex, endIndex, totalSegments) {
        // Create or update pagination container
        let paginationContainer = document.getElementById('segment-pagination-container');
        
        if (!paginationContainer) {
            // Create pagination container after the table
            const tableCard = document.querySelector('.card');
            paginationContainer = document.createElement('div');
            paginationContainer.id = 'segment-pagination-container';
            paginationContainer.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; padding: 1rem 0; border-top: 1px solid #eee;';
            tableCard.appendChild(paginationContainer);
        }
        
        const infoDiv = document.createElement('div');
        infoDiv.style.cssText = 'color: #666; font-size: 0.9rem;';
        infoDiv.textContent = `Showing ${startIndex + 1}-${endIndex} of ${totalSegments} segments`;
        
        const buttonsDiv = document.createElement('div');
        buttonsDiv.style.cssText = 'display: flex; gap: 0.5rem;';
        
        const prevButton = document.createElement('button');
        prevButton.textContent = 'Previous';
        prevButton.style.cssText = 'padding: 0.5rem 1rem; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;';
        prevButton.disabled = currentSegmentPage <= 1;
        prevButton.addEventListener('click', () => changeSegmentPage(currentSegmentPage - 1));
        
        const nextButton = document.createElement('button');
        nextButton.textContent = 'Next';
        nextButton.style.cssText = 'padding: 0.5rem 1rem; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;';
        nextButton.disabled = currentSegmentPage >= totalPages;
        nextButton.addEventListener('click', () => changeSegmentPage(currentSegmentPage + 1));
        
        buttonsDiv.appendChild(prevButton);
        
        // Add page numbers
        const MAX_PAGES = 5;
        const startPage = Math.max(1, currentSegmentPage - Math.floor(MAX_PAGES / 2));
        const endPage = Math.min(totalPages, startPage + MAX_PAGES - 1);
        
        for (let i = startPage; i <= endPage; i++) {
            const pageButton = document.createElement('button');
            pageButton.textContent = i;
            pageButton.style.cssText = 'padding: 0.5rem 1rem; border: 1px solid #ddd; background: ' + (i === currentSegmentPage ? '#007bff' : 'white') + '; color: ' + (i === currentSegmentPage ? 'white' : '#333') + '; border-radius: 4px; cursor: pointer;';
            pageButton.addEventListener('click', () => changeSegmentPage(i));
            buttonsDiv.appendChild(pageButton);
        }
        
        buttonsDiv.appendChild(nextButton);
        
        paginationContainer.innerHTML = '';
        paginationContainer.appendChild(infoDiv);
        paginationContainer.appendChild(buttonsDiv);
    }
    
    // Issue #374: Change to a specific page for Segment Analysis
    function changeSegmentPage(page) {
        const totalPages = Math.ceil(densityData.length / SEGMENT_ROWS_PER_PAGE);
        if (page >= 1 && page <= totalPages) {
            currentSegmentPage = page;
            renderDensityTable(densityData);
        }
    }
    
    function showDensityError() {
        // Issue #361: Show informative message with run_id when artifacts are missing
        const tbody = document.querySelector('#density-table tbody');
        const runId = '{{ run_id if run_id else "latest run" }}';
        tbody.innerHTML = `<tr><td colspan="10" class="placeholder">⚠️ Error loading density data for run ID: ${runId}. Check logs.</td></tr>`;
    }
    
    function showSegmentDetail(seg_id) {
        // Fetch detailed data
        fetch(`/api/density/segment/${seg_id}`)
            .then(response => response.json())
            .then(detail => {
                renderSegmentDetail(detail);
            })
            .catch(error => {
                console.error('Error loading segment detail:', error);
            });
    }
    
    function renderSegmentDetail(detail) {
        // Update title
        document.getElementById('detail-title').textContent = `${detail.seg_id}: ${detail.name}`;
        
        // Update metrics with null checks
        const peakDensity = detail.peak_density || 0;
        document.getElementById('detail-peak-density').textContent = peakDensity.toFixed(3) + ' p/m²';
        
        const worstLos = detail.worst_los || 'Unknown';
        const losBadge = `<span class="badge-los badge-${worstLos}">${worstLos}</span>`;
        document.getElementById('detail-los-badge').innerHTML = losBadge;
        
        const peakRate = detail.peak_rate || 0;
        document.getElementById('detail-peak-rate').textContent = peakRate.toFixed(2) + ' p/s';
        document.getElementById('detail-active').textContent = detail.active || 'N/A';
        
        // Show heatmap or empty state
        const heatmapImg = document.getElementById('heatmap-image');
        const noBinData = document.getElementById('heatmap-placeholder');
        
        if (detail.heatmap_url) {
            heatmapImg.style.display = 'block';
            noBinData.style.display = 'none';
            heatmapImg.src = detail.heatmap_url;
        } else {
            heatmapImg.style.display = 'none';
            noBinData.style.display = 'block';
        }
        
        // Show detail panel
        document.getElementById('segment-detail').style.display = 'block';
        
        // Issue #374: Load bin details for selected segment
        loadBinDetailsForSegment(detail.seg_id);
        
        // Scroll to panel
        document.getElementById('segment-detail').scrollIntoView({ behavior: 'smooth' });
    }
    
    // Issue #374: Setup event listeners for bin details
    function setupBinDetailsEventListeners() {
        const losFilter = document.getElementById('bin-los-filter');
        const prevButton = document.getElementById('bin-prev-page');
        const nextButton = document.getElementById('bin-next-page');
        
        if (losFilter) {
            losFilter.addEventListener('change', applyBinDetailsFilter);
        }
        if (prevButton) {
            prevButton.addEventListener('click', () => changeBinDetailsPage(currentBinPage - 1));
        }
        if (nextButton) {
            nextButton.addEventListener('click', () => changeBinDetailsPage(currentBinPage + 1));
        }
        
        // Setup column sorting
        const sortableHeaders = document.querySelectorAll('#bin-details-table th.sortable');
        sortableHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const column = header.dataset.sort;
                sortBinDetails(column);
            });
        });
    }
    
    // Issue #374: Load bin details for a specific segment
    async function loadBinDetailsForSegment(segId) {
        const loadingDiv = document.getElementById('bin-details-loading');
        const contentDiv = document.getElementById('bin-details-content');
        
        if (loadingDiv) loadingDiv.style.display = 'block';
        if (contentDiv) contentDiv.style.display = 'none';
        
        try {
            const response = await fetch(`/api/bins?segment_id=${segId}&limit=50000`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            allBinDetailsData = data.bins || [];
            filteredBinDetailsData = [...allBinDetailsData];
            currentBinPage = 1;
            
            if (loadingDiv) loadingDiv.style.display = 'none';
            if (contentDiv) contentDiv.style.display = 'block';
            
            renderBinDetailsTable();
        } catch (error) {
            console.error('Failed to load bin details:', error);
            if (loadingDiv) {
                loadingDiv.style.display = 'block';
                loadingDiv.innerHTML = `<div>Error loading bin data: ${error.message}</div>`;
            }
        }
    }
    
    // Issue #374: Apply LOS filter to bin details
    function applyBinDetailsFilter() {
        const losFilter = document.getElementById('bin-los-filter');
        const selectedLOS = losFilter ? losFilter.value : '';
        
        if (!selectedLOS) {
            filteredBinDetailsData = [...allBinDetailsData];
        } else {
            filteredBinDetailsData = allBinDetailsData.filter(bin => 
                bin.los_class === selectedLOS
            );
        }
        
        currentBinPage = 1;
        renderBinDetailsTable();
    }
    
    // Issue #374: Render bin details table with pagination
    function renderBinDetailsTable() {
        const tbody = document.getElementById('bin-details-table-body');
        if (!tbody) return;
        
        tbody.innerHTML = '';
        
        const totalPages = Math.ceil(filteredBinDetailsData.length / BIN_ROWS_PER_PAGE);
        const startIndex = (currentBinPage - 1) * BIN_ROWS_PER_PAGE;
        const endIndex = Math.min(startIndex + BIN_ROWS_PER_PAGE, filteredBinDetailsData.length);
        const pageData = filteredBinDetailsData.slice(startIndex, endIndex);
        
        pageData.forEach((bin, index) => {
            const row = createBinDetailsRow(bin, startIndex + index);
            tbody.appendChild(row);
        });
        
        updateBinDetailsPagination(totalPages, startIndex, endIndex);
    }
    
    // Issue #374: Create a table row for bin detail
    function createBinDetailsRow(bin, rowIndex) {
        const row = document.createElement('tr');
        row.dataset.index = rowIndex;
        
        row.innerHTML = `
            <td>${bin.start_km.toFixed(3)} / ${bin.end_km.toFixed(3)}</td>
            <td class="text-center">${bin.t_start} / ${bin.t_end}</td>
            <td class="text-right">${bin.density.toFixed(2)}</td>
            <td class="text-right">${bin.rate.toFixed(2)}</td>
            <td class="text-center">
                <span class="badge-los badge-${bin.los_class}">${bin.los_class}</span>
            </td>
        `;
        
        return row;
    }
    
    // Issue #374: Update pagination controls
    function updateBinDetailsPagination(totalPages, startIndex, endIndex) {
        const infoSpan = document.getElementById('bin-pagination-info');
        const prevButton = document.getElementById('bin-prev-page');
        const nextButton = document.getElementById('bin-next-page');
        const pageNumbers = document.getElementById('bin-page-numbers');
        
        if (infoSpan) {
            infoSpan.textContent = `Showing ${startIndex + 1}-${endIndex} of ${filteredBinDetailsData.length.toLocaleString()} bins`;
        }
        
        if (prevButton) {
            prevButton.disabled = currentBinPage <= 1;
        }
        
        if (nextButton) {
            nextButton.disabled = currentBinPage >= totalPages;
        }
        
        if (pageNumbers) {
            pageNumbers.innerHTML = '';
            
            const MAX_PAGES = 5;
            const startPage = Math.max(1, currentBinPage - Math.floor(MAX_PAGES / 2));
            const endPage = Math.min(totalPages, startPage + MAX_PAGES - 1);
            
            for (let i = startPage; i <= endPage; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.className = i === currentBinPage ? 'active' : '';
                button.style.padding = '0.5rem 1rem';
                button.style.border = '1px solid #ddd';
                button.style.background = i === currentBinPage ? '#007bff' : 'white';
                button.style.color = i === currentBinPage ? 'white' : '#333';
                button.style.borderRadius = '4px';
                button.style.cursor = 'pointer';
                button.addEventListener('click', () => changeBinDetailsPage(i));
                pageNumbers.appendChild(button);
            }
        }
    }
    
    // Issue #374: Change to a specific page
    function changeBinDetailsPage(page) {
        const totalPages = Math.ceil(filteredBinDetailsData.length / BIN_ROWS_PER_PAGE);
        if (page >= 1 && page <= totalPages) {
            currentBinPage = page;
            renderBinDetailsTable();
        }
    }
    
    // Issue #374: Sort bin details table
    let currentBinSort = { column: null, direction: 'asc' };
    
    function sortBinDetails(column) {
        if (currentBinSort.column === column) {
            currentBinSort.direction = currentBinSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            currentBinSort.column = column;
            currentBinSort.direction = 'asc';
        }
        
        // Update header classes
        document.querySelectorAll('#bin-details-table th.sortable').forEach(th => {
            th.classList.remove('sort-asc', 'sort-desc');
            if (th.dataset.sort === column) {
                th.classList.add(`sort-${currentBinSort.direction}`);
            }
        });
        
        // Sort the data
        filteredBinDetailsData.sort((a, b) => {
            let aVal = a[column];
            let bVal = b[column];
            
            // Handle numeric columns
            if (['start_km', 'end_km', 'density', 'rate'].includes(column)) {
                aVal = parseFloat(aVal) || 0;
                bVal = parseFloat(bVal) || 0;
            }
            
            // Handle time columns
            if (column.startsWith('t_')) {
                aVal = a[column] || '';
                bVal = b[column] || '';
                return currentBinSort.direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            }
            
            // Numeric comparison
            if (typeof aVal === 'number' && typeof bVal === 'number') {
                return currentBinSort.direction === 'asc' ? aVal - bVal : bVal - aVal;
            }
            
            // String comparison
            return currentBinSort.direction === 'asc' ? 
                String(aVal).localeCompare(String(bVal)) : 
                String(bVal).localeCompare(String(aVal));
        });
        
        renderBinDetailsTable();
    }
</script>
{% endblock %}

