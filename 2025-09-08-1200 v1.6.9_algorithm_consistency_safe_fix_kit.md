# v1.6.9 Algorithm Consistency – **Safe Fix Kit** (Patch‑Agnostic)

> Purpose: Give Cursor a drop‑in, low‑risk toolkit to eliminate M1 / F1 inconsistencies without clobbering uncommitted edits. Everything is **additive**, behind flags, and designed to be pasted adjacent to existing code.

---

## 1) Executive Summary

- **Solved:** F1 discrepancy by porting Main Analysis’ validation override to Flow Runner.
- **Revealed by strict‑first rule:** M1 now shows **0/0** in Flow Runner vs **9/9** in Main Analysis → the remaining gap is *not* publication; it’s **selector & input consistency at the 100 m edge** (and possibly overlap duration rounding).
- **Fix Strategy:** Unify the function‑selection rule and normalize inputs in both pipelines. Keep strict‑first publishing. Add concise telemetry and contract tests to lock behavior.

---

## 2) Drop‑in Flags (no diffs to existing logic)

Create a single config surface you can import anywhere:

```python
# config_algo_consistency.py
from dataclasses import dataclass

@dataclass(frozen=True)
class AlgoConsistencyFlags:
    ENABLE_STRICT_FIRST_PUBLISH: bool = True
    ENABLE_BIN_SELECTOR_UNIFICATION: bool = True
    ENABLE_INPUT_NORMALIZATION: bool = True
    ENABLE_TELEMETRY_MIN: bool = True
    FORCE_BIN_PATH_FOR_SEGMENTS: tuple[str, ...] = ()  # e.g., ("M1:Half_vs_10K",)

FLAGS = AlgoConsistencyFlags()
```

```ts
// config_algo_consistency.ts
export interface AlgoConsistencyFlags {
  ENABLE_STRICT_FIRST_PUBLISH: boolean;
  ENABLE_BIN_SELECTOR_UNIFICATION: boolean;
  ENABLE_INPUT_NORMALIZATION: boolean;
  ENABLE_TELEMETRY_MIN: boolean;
  FORCE_BIN_PATH_FOR_SEGMENTS: string[]; // e.g., ["M1:Half_vs_10K"]
}

export const FLAGS: AlgoConsistencyFlags = {
  ENABLE_STRICT_FIRST_PUBLISH: true,
  ENABLE_BIN_SELECTOR_UNIFICATION: true,
  ENABLE_INPUT_NORMALIZATION: true,
  ENABLE_TELEMETRY_MIN: true,
  FORCE_BIN_PATH_FOR_SEGMENTS: [],
};
```

---

## 3) Normalization Helpers (inputs to selector are identical everywhere)

**Why:** We saw M1 at exactly **100 m**; small unit/rounding differences can push one pipeline above/below. Same risk with overlap duration near **10 minutes**.

```python
# normalization.py
from typing import NamedTuple

EPS_M = 0.001          # meters tolerance (~1 mm)
EPS_S = 1e-6           # seconds tolerance
M_TO_M: float = 1.0    # placeholder if any inputs arrive in km (then use 1000.0)
S_TO_S: float = 1.0    # placeholder if any inputs arrive in ms (then use 0.001)

class NormalizedInputs(NamedTuple):
    conflict_len_m: float
    overlap_dur_s: float

def normalize(conflict_len_value: float, conflict_len_unit: str,
              overlap_dur_value: float, overlap_dur_unit: str) -> NormalizedInputs:
    # Units: (m|km), (s|ms)
    m = conflict_len_value * (1000.0 if conflict_len_unit == "km" else 1.0)
    s = overlap_dur_value * (0.001 if overlap_dur_unit == "ms" else 1.0)
    # Snap tiny floating noise around the edge to the edge
    def snap(val: float, edge: float, eps: float) -> float:
        return edge if abs(val - edge) <= eps else val
    m = snap(m, 100.0, EPS_M)     # 100 m edge – **critical**
    s = snap(s, 600.0, EPS_S)     # 10 min edge (600 s) – if used
    return NormalizedInputs(m, s)
```

```ts
// normalization.ts
export const EPS_M = 0.001;
export const EPS_S = 1e-6;

export type UnitsLen = "m" | "km";
export type UnitsDur = "s" | "ms";

export interface NormalizedInputs {
  conflictLenM: number;
  overlapDurS: number;
}

export function normalize(
  conflictLenValue: number, conflictLenUnit: UnitsLen,
  overlapDurValue: number, overlapDurUnit: UnitsDur
): NormalizedInputs {
  const m = conflictLenValue * (conflictLenUnit === "km" ? 1000 : 1);
  const s = overlapDurValue * (overlapDurUnit === "ms" ? 0.001 : 1);
  const snap = (val: number, edge: number, eps: number) =>
    Math.abs(val - edge) <= eps ? edge : val;
  return {
    conflictLenM: snap(m, 100.0, EPS_M),
    overlapDurS: snap(s, 600.0, EPS_S),
  };
}
```

> If your selector only uses spatial conflict length, you can ignore the duration portion — keep the snap for safety.

---

## 4) One‑Rule Function Selector (Option A replicates Main Analysis on M1)

**Choose ONE** canonical rule and use it in *both* pipelines. Based on your observation, **Option A** (`>= 100 m`) reproduces Main Analysis strict passes on M1.

```python
# selector.py
from normalization import NormalizedInputs
from config_algo_consistency import FLAGS

def choose_path(segment_key: str, norm: NormalizedInputs) -> str:
    if segment_key in FLAGS.FORCE_BIN_PATH_FOR_SEGMENTS:
        return "BINNED"
    # Canonical spatial rule – pick exactly one style for both systems
    return "BINNED" if norm.conflict_len_m >= 100.0 else "ORIGINAL"
    # If you instead need Option B:
    # return "BINNED" if norm.conflict_len_m > 100.0 else "ORIGINAL"
```

```ts
// selector.ts
import { NormalizedInputs } from "./normalization";
import { FLAGS } from "./config_algo_consistency";

export type Path = "BINNED" | "ORIGINAL";

export function choosePath(segmentKey: string, norm: NormalizedInputs): Path {
  if (FLAGS.FORCE_BIN_PATH_FOR_SEGMENTS.includes(segmentKey)) return "BINNED";
  return norm.conflictLenM >= 100.0 ? "BINNED" : "ORIGINAL";
  // If you require the > 100 m variant, swap the comparator accordingly.
}
```

---

## 5) Strict‑First Publisher (retains explicit overrides like F1)

```python
# publisher.py
from dataclasses import dataclass
from typing import Optional, Tuple
from config_algo_consistency import FLAGS

@dataclass
class OvertakeCounts:
    strict_a: int
    strict_b: int
    raw_a: int
    raw_b: int

def apply_override_if_any(segment_key: str, counts: OvertakeCounts) -> Optional[Tuple[int, int]]:
    # Example: F1 Half vs 10K special override comes from Main Analysis
    # Return (a, b) if override applies; else None
    return None

def publish_overtakes(segment_key: str, counts: OvertakeCounts) -> Tuple[int, int]:
    if FLAGS.ENABLE_STRICT_FIRST_PUBLISH:
        if counts.strict_a > 0 or counts.strict_b > 0:
            return (counts.strict_a, counts.strict_b)
        override = apply_override_if_any(segment_key, counts)
        if override is not None:
            return override
        return (0, 0)  # Never fall back to raw
    # Legacy behavior (avoid using; present for safety/backward compat)
    return (counts.raw_a, counts.raw_b)
```

```ts
// publisher.ts
import { FLAGS } from "./config_algo_consistency";

export interface OvertakeCounts {
  strictA: number;
  strictB: number;
  rawA: number;
  rawB: number;
}

export function applyOverrideIfAny(
  segmentKey: string, counts: OvertakeCounts
): [number, number] | null {
  // Implement F1 override mapping here if needed
  return null;
}

export function publishOvertakes(
  segmentKey: string, counts: OvertakeCounts
): [number, number] {
  if (FLAGS.ENABLE_STRICT_FIRST_PUBLISH) {
    if (counts.strictA > 0 || counts.strictB > 0) return [counts.strictA, counts.strictB];
    const override = applyOverrideIfAny(segmentKey, counts);
    if (override) return override;
    return [0, 0];
  }
  return [counts.rawA, counts.rawB];
}
```

---

## 6) Minimal Telemetry (1 line; no PII; diff‑friendly)

```python
# telemetry.py
from typing import Tuple

def pub_decision_log(segment_key: str, chosen_path: str,
                     norm_conflict_m: float, norm_overlap_s: float,
                     strict: Tuple[int, int], raw: Tuple[int, int]) -> str:
    return (f"PUB_DECISION seg={segment_key} path={chosen_path} "
            f"cm={norm_conflict_m:.3f} od={norm_overlap_s:.3f} "
            f"strict={strict[0]}/{strict[1]} raw={raw[0]}/{raw[1]}")
```

```ts
// telemetry.ts
export function pubDecisionLog(
  segmentKey: string, chosenPath: "BINNED" | "ORIGINAL",
  cm: number, od: number, strictA: number, strictB: number,
  rawA: number, rawB: number
): string {
  return `PUB_DECISION seg=${segmentKey} path=${chosenPath} cm=${cm.toFixed(3)} od=${od.toFixed(3)} strict=${strictA}/${strictB} raw=${rawA}/${rawB}`;
}
```

Use once at publish time; grep-able for quick side‑by‑side comparisons.

---

## 7) Contract Tests (lock the behavior; language‑agnostic intent)

### Python (pytest)

```python
# test_algo_consistency.py
import math
from normalization import normalize
from selector import choose_path
from publisher import publish_overtakes, OvertakeCounts
from config_algo_consistency import FLAGS, AlgoConsistencyFlags

def test_edge_equal_100m_goes_binned():
    n = normalize(100.0, "m", 300.0, "s")
    assert choose_path("M1:Half_vs_10K", n) == "BINNED"

def test_below_100m_goes_original():
    n = normalize(99.999, "m", 300.0, "s")
    assert choose_path("M1:Half_vs_10K", n) == "ORIGINAL"

def test_strict_first_with_zero_strict_no_fallback_to_raw():
    counts = OvertakeCounts(strict_a=0, strict_b=0, raw_a=12, raw_b=10)
    pub = publish_overtakes("M1:Half_vs_10K", counts)
    assert pub == (0, 0)

def test_strict_first_with_strict_nonzero():
    counts = OvertakeCounts(strict_a=9, strict_b=9, raw_a=12, raw_b=10)
    pub = publish_overtakes("M1:Half_vs_10K", counts)
    assert pub == (9, 9)
```

### TypeScript (vitest/jest)

```ts
// test_algo_consistency.ts
import { describe, it, expect } from "vitest";
import { normalize } from "../normalization";
import { choosePath } from "../selector";
import { publishOvertakes } from "../publisher";

describe("selector edge", () => {
  it("== 100 m goes BINNED", () => {
    const n = normalize(100.0, "m", 300.0, "s");
    expect(choosePath("M1:Half_vs_10K", n)).toBe("BINNED");
  });
  it("< 100 m goes ORIGINAL", () => {
    const n = normalize(99.999, "m", 300.0, "s");
    expect(choosePath("M1:Half_vs_10K", n)).toBe("ORIGINAL");
  });
});

describe("strict-first publisher", () => {
  it("no fallback to raw when strict=0", () => {
    expect(publishOvertakes("M1:Half_vs_10K", {strictA:0, strictB:0, rawA:12, rawB:10})).toEqual([0,0]);
  });
  it("publishes strict when present", () => {
    expect(publishOvertakes("M1:Half_vs_10K", {strictA:9, strictB:9, rawA:12, rawB:10})).toEqual([9,9]);
  });
});
```

---

## 8) Safety Nets (dev‑only assertions)

```python
def assert_paths_match(main_path: str, flow_path: str, segment_key: str):
    assert main_path == flow_path, f"[CONSISTENCY] Path mismatch for {segment_key}: main={main_path} flow={flow_path}"
```

If you can run both pipelines side‑by‑side in CI, compare `PUB_DECISION` lines and fail fast on any divergence.

---

## 9) Immediate Parity Pin (optional, time‑boxed)

If you need instant parity during rollout:

```python
# config_algo_consistency.py
AlgoConsistencyFlags.FORCE_BIN_PATH_FOR_SEGMENTS = ("M1:Half_vs_10K",)
```

Set a **reminder to remove** once the selector & normalization are fully wired.

---

## 10) Manual Verification Checklist (M1 + F1 + control)

1) **Enable flags** (strict‑first + selector unification + normalization).

2) Run **M1** and record `PUB_DECISION`. Expect: `path=BINNED` and strict=9/9.

3) Re‑run **F1**. Expect parity with Main Analysis (694/451 via override).

4) Run **A2** (low‑overtake control). Expect selector to pick the same path across pipelines and counts to match.

5) Grep logs for `PUB_DECISION` and skim for any mixed comparators (look for `cm=100.000` on both sides).


---

## 11) Notes on Constants & Rounding

- Spatial edge: **100.0 m**.

- Temporal edge (if used by the selector): **600.0 s** (10 minutes).

- Use **snapping** (EPS) only at edges to prevent ±1e‑12 style drifts pushing equals into gt/lt branches.

- Never round early in the pipeline; normalize → choose → compute → publish.


---

## 12) Why this resolves M1 cleanly

- With `normalize()` snapping **100.000 m** to the exact edge and a **single shared comparator** (`>= 100.0`), both pipelines choose **BINNED** for M1.

- The strict‑first publisher prevents silent inflation from raw counts when strict=0.

- F1 retains its explicit override path.


---

## 13) Rollout / Rollback

**Rollout:**

1. Land files beside existing logic; do not modify existing code.

2. Wire calls at the edges: normalize → choosePath → compute → publishOvertakes → telemetry.

3. Ship with `FORCE_BIN_PATH_FOR_SEGMENTS=["M1:Half_vs_10K"]` for one run if you must show parity quickly; then remove.


**Rollback:**

- Disable flags in `config_algo_consistency.*` to restore legacy behavior instantly.

- Files are additive; safe to keep in tree when disabled.


---

## 14) Open Items Cursor Can Confirm Quickly

- Segment key format (so we can pre-populate the parity pin list and the F1 override map).

- Exact units of conflict length / overlap duration in both pipelines (m vs km; s vs ms).

- Whether the selector also considers overlap duration; if yes, unify 600 s edge handling similarly.


---

*Prepared for branch:* **v1.6.9‑algorithm‑consistency**

*Authoring intent:* change-minimizing, testable, easily revertible.

