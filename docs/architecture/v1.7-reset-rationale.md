# v1.7.0 Architecture Reset - Rationale

**Date:** 2025-11-01  
**Status:** Planning  
**Author:** Development Team via AI Analysis

---

## Executive Summary

v1.6.52 has accumulated significant technical debt through reactive development patterns. This document proposes a deliberate architecture reset for v1.7.0 to restore clarity and reduce maintenance burden.

---

## Current State Assessment (v1.6.52)

### Critical Issues Identified

**1. Dual Import Path Pattern**
```python
# Current pattern in app/main.py (lines 16-46)
try:
    from .density_api import router as density_router  # Relative
except ImportError:
    from density_api import router as density_router   # Absolute fallback
```

**Problems:**
- Import dependencies are opaque to static analysis
- Different behavior: local dev vs Docker vs Cloud Run
- Cannot safely refactor without runtime testing
- Grep/search tools give false negatives
- Archival attempts break production (Nov 2025 incident)

**2. Shadow Dependencies**
- Stub files appear unused in searches but are critical for Cloud Run
- No clear documentation of which files are actually deprecated
- Fear of removing anything due to hidden dependencies

**3. Architectural Debt Accumulation**
- 600+ commits of additive changes
- Features added reactively, not planned architecturally
- Module boundaries unclear
- Separation of concerns violated in multiple places

**4. Testing Gaps**
- E2E tests don't validate import paths
- Smoke tests don't catch import failures before runtime
- No architectural tests to enforce boundaries

---

## Specific Examples of Technical Debt

### Example 1: Failed Archival Attempt (Nov 2025)

**What Happened:**
- Analysis identified 9 "unused" files via grep
- Archived files: `density_api.py`, `report.py`, `map_api.py`, etc.
- Docker container crashed immediately: `ModuleNotFoundError`
- Root cause: Fallback imports in main.py not detected by search

**Impact:**
- Lost developer productivity (4+ hours)
- Revealed opaque dependency structure
- Demonstrated codebase is too fragile for routine maintenance

### Example 2: Multiple Deprecated Implementations

**Files with Explicit Deprecation Warnings:**
- `new_density_report.py` - marked deprecated Oct 2025
- `new_flagging.py` - marked deprecated Oct 2025
- `new_density_template_engine.py` - marked deprecated Oct 2025
- `storage.py` - replaced by `storage_service.py`

**Problem:**
- Cannot safely remove due to unclear dependencies
- "Deprecated" code remains in production indefinitely
- Increases cognitive load for new developers

### Example 3: Environment-Specific Behavior

**Local Development:**
- Uses relative imports (`.density_api`)
- Works with venv or Docker

**Cloud Run:**
- Uses absolute imports (`density_api`)
- Different code paths executed
- Behavior divergence risk

---

## Proposed v1.7.0 Architecture Reset

### Phase 1: Freeze v1.6.52 (Immediate)

**Actions:**
1. Declare v1.6.52 as **maintenance-only**
2. Critical bug fixes only - no new features
3. Document all known technical debt
4. Create comprehensive dependency map

**Duration:** 2 weeks

### Phase 2: Architecture Planning Branch (Week 3-4)

**Branch:** `refactor/v1.7-architecture`

**Goals:**
1. **Single Import Pattern**
   - Choose one: relative or absolute
   - Remove all try/except fallback patterns
   - Explicit dependency registration

2. **Clear Module Boundaries**
   ```
   /app
     /api          - FastAPI routes only
     /core         - Business logic, no HTTP
     /routes       - Additional route handlers
     /utils        - Shared utilities
     /validation   - Input validation
   ```

3. **Remove Legacy Cruft**
   - Safely remove deprecated files with clear import cleanup
   - Document what stays and why
   - Archive with restoration instructions

4. **Explicit Dependencies**
   - No hidden fallbacks
   - Clear dependency injection
   - Testable boundaries

### Phase 3: Staged Migration to v1.7.0 (Week 5-8)

**Not a Complete Rewrite:**
- Migrate clean, reviewed code from v1.6.52
- Refactor problematic areas only
- Leave legacy patterns behind intentionally

**Testing Strategy:**
- Import path validation tests
- Module boundary enforcement
- Architectural fitness tests
- Full E2E parity with v1.6.52

---

## Success Criteria for v1.7.0

**Code Quality:**
- ✅ Single, documented import pattern
- ✅ No try/except import fallbacks
- ✅ Clear module boundaries
- ✅ Zero deprecated files with warnings
- ✅ All imports traceable via static analysis

**Developer Experience:**
- ✅ New developers can understand structure in < 1 hour
- ✅ Safe to remove files when marked deprecated
- ✅ Refactoring doesn't require fear
- ✅ Environment parity (local = Docker = Cloud Run)

**Operations:**
- ✅ All E2E tests pass
- ✅ Cloud Run deployment works
- ✅ No behavior regressions
- ✅ Performance maintained or improved

---

## Risk Mitigation

**Risks:**
1. Breaking production during migration
2. Missing critical functionality
3. Extended development time
4. Team capacity constraints

**Mitigations:**
1. Keep v1.6.52 as stable fallback
2. Comprehensive test suite before migration
3. Phased rollout with monitoring
4. Clear rollback plan

---

## Decision Points

### Decision 1: Import Pattern Choice

**Options:**
- **A) Relative imports only** (`.density_api`)
  - Pro: Explicit module structure
  - Con: Verbose, harder to move files
  
- **B) Absolute imports only** (`from app.density_api`)
  - Pro: Clear, standard Python pattern
  - Con: Requires proper PYTHONPATH setup
  
- **C) Namespace packages** (`from app.api.density`)
  - Pro: Very clear structure
  - Con: Larger refactor required

**Recommendation:** Option B (absolute imports with proper package structure)

### Decision 2: Timeline

**Conservative:** 8 weeks (recommended)
**Aggressive:** 4 weeks (risky)
**Maintenance:** Ongoing patches to v1.6.52 (not recommended)

---

## Next Steps

**Immediate (This Week):**
1. ✅ Document this rationale
2. ⏳ Create dependency map of current imports
3. ⏳ Audit deprecated files with impact analysis
4. ⏳ Present plan to team/stakeholders

**Week 2:**
1. Freeze v1.6.52 features
2. Create architecture planning branch
3. Begin import pattern migration design
4. Set up architectural test framework

**Week 3-4:**
1. Implement new structure in planning branch
2. Migrate core modules
3. Test extensively
4. Document migration patterns

**Week 5-8:**
1. Complete migration
2. Full E2E validation
3. Performance testing
4. Deploy v1.7.0

---

## Questions for Team Discussion

1. **Timeline:** Can we commit to 8-week architecture reset?
2. **Resources:** Who can dedicate time to this effort?
3. **Risk Tolerance:** Comfortable with major refactor vs incremental patches?
4. **Deprecation Policy:** How long to support v1.6.52 after v1.7.0 ships?

---

## References

- Issue #418: Duplicate reports bug
- Issue #419: CI cleanup duplicate GCS upload logic
- Session Handoff 2025-11-01: Docker-first architecture
- Guardrails.md: Development standards
- Nov 2025 archival failure incident

---

**This is a turning point. We choose to build on a solid foundation rather than continue adding to technical debt.**

