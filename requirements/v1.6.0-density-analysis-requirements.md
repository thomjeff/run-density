# v1.6.0 Density Analysis Requirements & Workplan

**Version**: 1.3  
**Date**: 2025-09-03  
**Status**: Final Requirements with Gotchas Addressed  
**Dependencies**: Temporal Flow Analysis (v1.5.0) Complete  

**Note**: This document incorporates ChatGPT's corrections and clarified density analysis context:
- Corrected width handling (use `width_m` directly, no division)
- Improved data structures and API contracts
- Enhanced module design with dataclass-based approach
- Clearer integration patterns with orchestrator approach
- **CRITICAL**: Density analysis is independent of temporal flow - different runner count contexts
- **GOTCHAS ADDRESSED**: Edge cases, validation, performance, and integration considerations  

## 1. Overview

### 1.1 Purpose
Density analysis provides the "how tight" component that complements temporal flow's "when" and "how many" insights. While temporal flow measures runner interactions and timing, density analysis quantifies the spatial concentration of runners within segments.

### 1.2 Key Distinction: Flow vs Density
- **Temporal Flow**: Measures runner interactions, overtakes, merges, and timing patterns
- **Density Analysis**: Measures spatial concentration of runners per unit area/volume
- **Critical Difference**: Different runner count contexts - Flow counts overtaking runners, Density counts ALL runners in segment
- **Integration**: Flow provides the temporal context; density provides the spatial context

### 1.3 Architecture Principle
- **Separate Module**: `density.py` remains independent from `temporal_flow.py`
- **Single Source of Truth**: `segments.csv` serves both modules
- **No Hardcoding**: All parameters configurable via segments.csv or function parameters
- **Functional Separation**: Strict boundaries between flow and density calculations
- **Independent Calculations**: Density calculates its own runner counts (different context from flow)

## 2. Density Types & Definitions

### 2.1 Areal Density
**Definition**: Runners per square meter (runners/m²)  
**Purpose**: Measures how tightly packed runners are within a given area  
**Use Case**: Course width planning, safety assessments, marshalling decisions  
**Formula**: `areal_density = concurrent_runners / (segment_length_m × effective_width_m)`

### 2.2 Crowd Density  
**Definition**: Runners per meter of course length (runners/m)  
**Purpose**: Measures linear concentration along the course  
**Use Case**: Flow rate analysis, bottleneck identification, pacing considerations  
**Formula**: `crowd_density = concurrent_runners / segment_length_m`

### 2.3 Why Both Are Calculated
- **Areal Density**: Critical for safety (overcrowding risks) and course design
- **Crowd Density**: Essential for flow management and operational planning
- **Complementary**: Together they provide complete spatial understanding

## 3. Data Structures & API Contracts

### 3.1 Input Data
- `segments.csv` (single source of truth for `from_km`, `to_km`, `width_m`, `direction`)
- `your_pace_data.csv` (runner pace data with start_offset)
- `start_times` (event start times)
- **Config** (defaults but overridable):
  - `bin_seconds` (default: 30)
  - `threshold_areal` (default: 1.2 runners/m²)
  - `threshold_crowd` (default: 2.0 runners/m)

### 3.2 Core Derived Fields
- `segment_length_m = (to_km - from_km) × 1000`
- `width_m = actual usable course width from segments.csv`
- `concurrent_runners = ALL runners present in segment at time T (density context)`

### 3.3 Output Data Structures

#### Per-Segment, Per-Time-Bin Output
```json
{
  "segment_id": "A1a",
  "t_start": "08:45:00",
  "t_end": "08:45:30",
  "concurrent_runners": 234,
  "areal_density": 1.62,
  "crowd_density": 2.34,
  "los_areal": "Busy",
  "los_crowd": "Medium",
  "flags": []
}
```

#### Per-Segment Aggregate Output
```json
{
  "segment_id": "A1a",
  "peak_areal_density": 1.87,
  "peak_areal_time_window": ["08:44:30","08:48:30"],
  "peak_crowd_density": 3.12,
  "peak_crowd_time_window": ["08:45:00","08:46:00"],
  "tot_areal_sec": 720,
  "tot_crowd_sec": 420,
  "los_areal_distribution": {"Comfortable": 0.40, "Busy": 0.45, "Constrained": 0.15},
  "los_crowd_distribution": {"Low": 0.35, "Medium": 0.40, "High": 0.25}
}
```

### 3.4 Module Surface (Dataclass-Based Design)
```python
@dataclass(frozen=True)
class DensityConfig:
    bin_seconds: int = 30
    threshold_areal: float = 1.2  # runners/m^2
    threshold_crowd: float = 2.0  # runners/m

@dataclass(frozen=True)
class SegmentMeta:
    segment_id: str
    from_km: float
    to_km: float
    width_m: float
    direction: str  # "uni" | "bi"

def compute_density_timeseries(...): ...
def summarize_density(...): ...
```

## 4. Mathematical Formulas

### 4.1 Core Density Calculations

#### Areal Density
```
areal_density = concurrent_runners / (segment_length_m × width_m)

Where:
- concurrent_runners = runners present in segment at time t
- segment_length_m = (to_km - from_km) × 1000
- width_m = actual usable course width from segments.csv
```

#### Crowd Density
```
crowd_density = concurrent_runners / segment_length_m

Where:
- concurrent_runners = runners present in segment at time t  
- segment_length_m = (to_km - from_km) × 1000
```

#### Effective Width (Corrected)
```
effective_width_m = width_m  (always, regardless of direction)

Note: segments.csv contains the actual usable course width (width_m) 
for each segment, with bi-directional adjustments already calculated.
```

### 4.2 Time-Over-Threshold (TOT) Calculations

#### TOT for Areal Density
```
tot_areal = Σ(time_bins where areal_density > threshold_areal)

Where:
- threshold_areal = configurable (default: 1.2 runners/m²)
- time_bins = temporal resolution (default: 30 seconds)
```

#### TOT for Crowd Density
```
tot_crowd = Σ(time_bins where crowd_density > threshold_crowd)

Where:
- threshold_crowd = configurable (default: 2.0 runners/m)
- time_bins = temporal resolution (default: 30 seconds)
```

### 4.3 Level of Service (LOS) Classification

#### Areal Density LOS
```
LOS_areal = {
    "Comfortable": areal_density < 1.0 runners/m²
    "Busy": 1.0 ≤ areal_density < 1.8 runners/m²  
    "Constrained": areal_density ≥ 1.8 runners/m²
}
```

#### Crowd Density LOS
```
LOS_crowd = {
    "Low": crowd_density < 1.5 runners/m
    "Medium": 1.5 ≤ crowd_density < 3.0 runners/m
    "High": crowd_density ≥ 3.0 runners/m
}
```

## 5. Critical Gotchas & Validation Requirements

### 5.1 Runner Count Context Validation
- **CRITICAL**: Density MUST calculate its own runner counts (ALL runners in segment)
- **GOTCHA**: Never reuse flow's concurrent runner counts - they count different things
- **Action**: Add explicit code comments and tests that density uses ALL runners present
- **Validation**: Unit tests must verify density counts ≠ flow counts for same time bins

### 5.2 Edge Segment Handling
- **GOTCHA**: Very short segments (<50m) will produce extreme density values
- **Action**: Add validation check for `segment_length_m < 100m`
- **Handling**: Flag with warning, consider exclusion or capped values
- **Default**: Skip segments with `segment_length_m < 50m` with logged warning

### 5.3 Width_m Validation
- **GOTCHA**: Missing or zero `width_m` causes division by zero crashes
- **Action**: Add validator in Phase 1 - skip segments with invalid `width_m`
- **Validation**: `width_m > 0` and `width_m` is not null/NaN
- **Handling**: Skip with logged warning, don't fail entire pipeline

### 5.4 Time Bin Alignment
- **GOTCHA**: Off-by-one alignment if density recalculates bins separately
- **Action**: Orchestrator provides shared `time_index` to both modules
- **Validation**: Ensure identical time bin boundaries between flow and density
- **Implementation**: Use same time bin calculation logic, not independent calculations

### 5.5 TOT Threshold Consistency
- **GOTCHA**: Edge cases at exactly threshold value (e.g., = 1.2) - count or not?
- **Action**: Document and enforce consistent comparator (> vs ≥)
- **Standard**: Use `>=` for TOT inclusion, `>` for LOS classification
- **Validation**: Unit tests for boundary values (exactly at threshold)

### 5.6 Performance Considerations
- **GOTCHA**: Python dict/list loops across 36 segments × thousands of bins
- **Action**: Consider lightweight NumPy arrays for inner loops
- **Implementation**: Wrap outputs back into dicts for reporting
- **Target**: <5s per segment, <10s for combined reports

### 5.7 Narrative Smoothing
- **GOTCHA**: Rapid LOS fluctuations (Comfortable ↔ Busy every bin) create noise
- **Action**: Consider smoothing transitions or "sustained LOS >N mins"
- **Implementation**: Report sustained periods rather than per-bin noise
- **Threshold**: Minimum 2-minute sustained periods for narrative inclusion

### 5.8 Testing Tolerances
- **GOTCHA**: Floating point precision and boundary bin tolerances
- **Action**: Define epsilon (1e-6) for float comparisons
- **Time Windows**: ±1 bin tolerance for time window comparisons
- **Golden Tests**: Include tolerance specifications in test framework

### 5.9 Flags System
- **GOTCHA**: Output schema includes "flags": [] but undefined
- **Action**: Define placeholder flags for Phase 1
- **Flags**: `["width_missing", "short_segment", "invalid_data", "edge_case"]`
- **Implementation**: Even if unused, define structure for downstream compatibility

### 5.10 Future Scalability
- **GOTCHA**: Hard-coding width_m logic prevents future GPX integration
- **Action**: Make width provider pluggable from start
- **Implementation**: Abstract width calculation behind interface
- **Future**: Easy drop-in for dynamic GPX-based width provider

## 6. Runner Count Contexts - Critical Distinction

### 6.1 Temporal Flow Runner Counts
- **Context**: Overtake/interaction detection
- **Purpose**: Count runners involved in actual overtakes/merges
- **Scope**: Convergence zones, interaction events
- **Example**: Only runners who actually overtake each other
- **Segments**: Primarily overtake_flag = 'y' segments

### 6.2 Density Runner Counts
- **Context**: Spatial concentration analysis
- **Purpose**: Count ALL runners present in segment at time T
- **Scope**: Entire segment, all time periods
- **Example**: All runners in segment regardless of interactions
- **Segments**: ALL 36 segments (regardless of overtake_flag)

### 6.3 Key Differences
- **Temporal Flow**: "How many runners are overtaking?"
- **Density**: "How many runners are in this segment?"
- **Independence**: Density calculates its own runner counts
- **Same Data**: Both use same pace data, start_times, segments.csv
- **Same Time Bins**: Both use 30-second intervals

## 7. Dependencies with Temporal Flow

### 7.1 Data Dependencies
- **Runner Data**: Density analysis uses same pace data and start_times as temporal flow
- **Segment Data**: Both modules share segments.csv as single source of truth
- **Time Bins**: Both modules use same time bin structure (30 seconds)
- **Independent Calculations**: Density calculates its own concurrent runner counts

### 7.2 Calculation Dependencies
- **Independent Calculations**: Density calculations are completely independent of flow calculations
- **Shared Inputs**: Both use same runner data and segment definitions
- **No Circular Dependencies**: Flow does not depend on density results
- **Different Contexts**: Flow counts overtaking runners, Density counts ALL runners in segment

### 7.3 Integration Points (Orchestrator Pattern)
- **No Circular Dependencies**: Orchestrator calls both flow and density independently
- **Combined Reporting**: Both analyses can be reported together via orchestrator
- **Shared Parameters**: Both use same time bins and segment definitions
- **Complementary Insights**: Flow provides "when" (interactions), density provides "how tight" (spatial concentration)
- **Independent Processing**: Density processes ALL 36 segments regardless of overtake_flag

## 8. Reporting Integration

### 8.1 Flow Summary Integration
```
Segment Summary Report:
├── Flow Analysis
│   ├── Peak concurrent runners
│   ├── Peak time window
│   ├── Total interactions
│   └── Flow type (overtake/merge/diverge)
└── Density Analysis
    ├── Peak areal density (runners/m²)
    ├── Peak crowd density (runners/m)
    ├── LOS classification
    └── TOT metrics
```

### 8.2 Flow Detailed Analysis Integration
```
Detailed Analysis Report:
├── Temporal Flow Details
│   ├── Entry/exit times
│   ├── Overlap windows
│   ├── Runner characteristics
│   └── Deep dive analysis
└── Density Analysis Details
    ├── Density time series
    ├── LOS transitions
    ├── TOT breakdowns
    └── Operational recommendations
```

### 8.3 Combined Narrative
- **Flow Narrative**: "Peak interactions occur at 08:45 with 234 concurrent runners"
- **Density Narrative**: "Peak density reaches 1.6 runners/m² (Busy LOS) for 12 minutes"
- **Combined**: "Peak interactions at 08:45 with 234 runners create Busy conditions (1.6/m²) for 12 minutes"

## 9. Test Plan Strategy

### 9.1 Unit Testing
- **Density Calculations**: Test areal and crowd density formulas with known inputs
- **LOS Classification**: Verify LOS thresholds and classifications
- **TOT Calculations**: Test time-over-threshold logic
- **Width Adjustments**: Test bi-directional width calculations

### 9.2 Integration Testing
- **Segments.csv Integration**: Verify width_m parameter usage
- **Temporal Flow Integration**: Test combined reporting
- **API Endpoint Testing**: Verify density endpoints work correctly

### 9.3 Validation Testing
- **Known Segments**: Test against segments with known density characteristics
- **Edge Cases**: Test with very narrow/wide segments, high/low runner counts
- **Performance Testing**: Verify calculations complete within acceptable time

### 9.4 Comprehensive Testing
- **All 36 Segments**: Run density analysis on all segments
- **Expected vs Actual**: Compare against expected density values
- **Regression Testing**: Ensure changes don't break existing functionality

## 10. Workplan & Milestones

### Phase 1: Core Density Engine (Week 1)
**Milestone 1.1**: Basic density calculations with validation
- [ ] Implement areal density calculation
- [ ] Implement crowd density calculation  
- [ ] Add effective width adjustment logic
- [ ] **CRITICAL**: Add width_m validation (skip segments with invalid width_m)
- [ ] **CRITICAL**: Add edge segment handling (skip segments <50m)
- [ ] **CRITICAL**: Add runner count context validation (density ≠ flow counts)
- [ ] **Commit**: "Implement core density calculations with validation"

**Milestone 1.2**: LOS classification system with TOT consistency
- [ ] Implement areal density LOS classification
- [ ] Implement crowd density LOS classification
- [ ] Add configurable thresholds
- [ ] **CRITICAL**: Ensure TOT threshold consistency (>= for TOT, > for LOS)
- [ ] **CRITICAL**: Add boundary value testing (exactly at threshold)
- [ ] **Commit**: "Add LOS classification system with TOT consistency"

### Phase 2: TOT & Advanced Metrics (Week 1)
**Milestone 2.1**: Time-over-threshold calculations with performance
- [ ] Implement TOT for areal density
- [ ] Implement TOT for crowd density
- [ ] Add configurable thresholds
- [ ] **CRITICAL**: Consider NumPy arrays for performance (36 segments × thousands of bins)
- [ ] **CRITICAL**: Add flags system placeholder (width_missing, short_segment, etc.)
- [ ] **Commit**: "Implement TOT calculations with performance optimizations"

**Milestone 2.2**: Density time series analysis with narrative smoothing
- [ ] Generate density time series data
- [ ] Add peak density identification
- [ ] Implement density distribution analysis
- [ ] **CRITICAL**: Add narrative smoothing (sustained LOS >2 mins, not per-bin noise)
- [ ] **CRITICAL**: Make width provider pluggable for future GPX integration
- [ ] **Commit**: "Add density time series analysis with narrative smoothing"

### Phase 3: Integration & Reporting (Week 2)
**Milestone 3.1**: API endpoint integration with time bin alignment
- [ ] Create density analysis endpoint
- [ ] Integrate with existing API structure
- [ ] Add error handling and validation
- [ ] **CRITICAL**: Ensure time bin alignment (orchestrator provides shared time_index)
- [ ] **Commit**: "Add density API endpoint with time bin alignment"

**Milestone 3.2**: Combined reporting
- [ ] Integrate density with flow summary reports
- [ ] Add combined narrative generation
- [ ] Implement detailed analysis integration
- [ ] **Commit**: "Integrate density with flow reporting"

### Phase 4: Testing & Validation (Week 2)
**Milestone 4.1**: Comprehensive testing with tolerances
- [ ] Run density analysis on all 36 segments
- [ ] Generate comprehensive test report
- [ ] Validate against expected values
- [ ] **CRITICAL**: Add testing tolerances (epsilon 1e-6 for floats, ±1 bin for time windows)
- [ ] **CRITICAL**: Test boundary values (exactly at threshold)
- [ ] **Commit**: "Complete comprehensive density testing with tolerances"

**Milestone 4.2**: Documentation & release
- [ ] Update CHANGELOG.md with density features
- [ ] Create density analysis documentation
- [ ] Prepare for v1.6.0 release
- [ ] **Commit**: "Prepare density analysis for v1.6.0 release"

## 11. Success Criteria

### 11.1 Functional Requirements
- [ ] All 36 segments can be analyzed for density
- [ ] Both areal and crowd density calculations work correctly
- [ ] LOS classification provides meaningful insights
- [ ] TOT metrics support operational planning
- [ ] Integration with temporal flow reporting works seamlessly

### 11.2 Performance Requirements
- [ ] Density calculations complete within 5 seconds per segment
- [ ] Combined flow+density reports generate within 10 seconds
- [ ] API endpoints respond within 2 seconds
- [ ] Memory usage remains within acceptable limits

### 11.3 Quality Requirements
- [ ] 100% test coverage for density calculations
- [ ] All 36 segments pass comprehensive validation
- [ ] No hardcoded values in density module
- [ ] Clear separation between flow and density functionality

## 12. Risk Mitigation

### 12.1 Technical Risks
- **Risk**: Performance issues with large datasets
- **Mitigation**: Implement efficient algorithms and caching

- **Risk**: Integration complexity with existing flow system
- **Mitigation**: Maintain strict module separation and clear interfaces

### 12.2 Data Risks
- **Risk**: Missing or incorrect width_m values in segments.csv
- **Mitigation**: Add validation and default values

- **Risk**: Inconsistent density calculations across segments
- **Mitigation**: Comprehensive testing and validation framework

## 13. Future Enhancements

### 13.1 Advanced Features
- **Dynamic Width**: Use GPX data for actual course width
- **Weather Adjustments**: Factor in weather conditions on density
- **Historical Analysis**: Compare density across multiple race years

### 13.2 Visualization
- **Density Heatmaps**: Visual representation of density over time
- **LOS Transitions**: Charts showing LOS changes over time
- **Combined Dashboards**: Flow and density visualizations together

---

**Document Status**: Ready for Review  
**Next Step**: Begin Phase 1 implementation  
**Estimated Completion**: 2 weeks  
**Dependencies**: Temporal Flow Analysis (v1.5.0) Complete ✅
