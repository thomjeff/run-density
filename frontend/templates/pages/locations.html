{% extends "base.html" %}

{% block title %}Locations Report{% endblock %}

{% block extra_head %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    #locations-map {
        height: 500px;
        border-radius: 4px;
        overflow: hidden;
        position: relative;
        background: transparent !important;
    }
    
    .map-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 1rem 2rem;
        border-radius: 4px;
        font-weight: 500;
        color: #666;
        z-index: 1000;
    }
    
    .location-tooltip {
        font-size: 0.875rem;
        line-height: 1.4;
    }
    
    .location-popup {
        font-size: 0.875rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <h2>Locations Report</h2>
    {% if meta %}
    {% endif %}
</div>

<!-- Map Container -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Course Map</h3>
    <div id="locations-map" aria-label="Course locations map" style="position: relative;">
        <div class="map-loading">Loading map data...</div>
        
        <!-- Filter Controls Overlay -->
        <div id="map-filter-controls" style="position: absolute; top: 10px; right: 10px; z-index: 1000; background: rgba(255, 255, 255, 0.95); padding: 0.75rem; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); display: none; max-width: 300px;">
            <div style="display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-end;">
                <button id="clear-filter-btn" onclick="clearMapFilter()" style="padding: 0.4rem 0.8rem; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">
                    Clear Filter
                </button>
                <span id="filter-status" style="color: #495057; font-size: 0.85rem; text-align: right; line-height: 1.3;"></span>
            </div>
        </div>
    </div>
</div>

<!-- Locations Table -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Course Resource Timing</h3>
    <p style="margin-bottom: 1rem; color: #7f8c8d; font-size: 0.875rem;">
        Operational timing windows for fixed point locations on the course (traffic control points, water stops, turnarounds).
    </p>
    
    <!-- Filter Controls (Issue #483) -->
    <div class="card" style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 4px; position: relative; z-index: 100;">
        <div style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: end;">
            <!-- Type Filter -->
            <div style="position: relative; z-index: 101;">
                <label for="filter-type" style="display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem; color: #2c3e50;">Type</label>
                <select id="filter-type" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem; position: relative; z-index: 102; background: white;">
                    <option value="">All Types</option>
                </select>
            </div>
            
            <!-- Visual Separator -->
            <div style="width: 1px; background-color: #ddd; align-self: stretch; margin: 0 0.5rem;"></div>
            
            <!-- Zone Filter -->
            <div style="position: relative; z-index: 101;">
                <label for="filter-zone" style="display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem; color: #2c3e50;">Zone</label>
                <select id="filter-zone" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem; position: relative; z-index: 102; background: white;">
                    <option value="">All Zones</option>
                </select>
            </div>
            
            <!-- Visual Separator -->
            <div style="width: 1px; background-color: #ddd; align-self: stretch; margin: 0 0.5rem;"></div>
            
            <!-- Resource Filter (Issue #591) -->
            <div style="position: relative; z-index: 101;">
                <label for="filter-resource" style="display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem; color: #2c3e50;">Resource</label>
                <select id="filter-resource" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem; position: relative; z-index: 102; background: white;">
                    <option value="">All Resources</option>
                </select>
            </div>
            
            <!-- Visual Separator -->
            <div style="width: 1px; background-color: #ddd; align-self: stretch; margin: 0 0.5rem;"></div>
            
            <!-- Flag Filter (Issue #598) -->
            <div style="position: relative; z-index: 101;">
                <label for="filter-flag" style="display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem; color: #2c3e50;">Flag</label>
                <select id="filter-flag" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem; position: relative; z-index: 102; background: white;">
                    <option value="">All</option>
                    <option value="Y">Flagged</option>
                    <option value="N">Not Flagged</option>
                </select>
            </div>
            
            <!-- Visual Separator -->
            <div style="width: 1px; background-color: #ddd; align-self: stretch; margin: 0 0.5rem;"></div>
            
            <!-- Last Runner Filter -->
            <div>
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem; color: #2c3e50;">Last Runner</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                    <input type="text" id="filter-last-runner-min" placeholder="Min (HHMM)" maxlength="4" pattern="[0-9]{4}" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem;">
                    <span style="color: #666;">to</span>
                    <input type="text" id="filter-last-runner-max" placeholder="Max (HHMM)" maxlength="4" pattern="[0-9]{4}" style="flex: 0.5; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem;">
                </div>
            </div>
            
            <!-- Visual Separator -->
            <div style="width: 1px; background-color: #ddd; align-self: stretch; margin: 0 0.5rem;"></div>
            
            <!-- Clear Filters Button -->
            <div style="display: flex; align-items: end;">
                <button id="clear-filters-btn" style="padding: 0.5rem 1rem; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; width: auto;">
                    Clear Filters
                </button>
            </div>
        </div>
    </div>
    
    <!-- Scrollable table container (Issue #484) -->
    <div id="locations-table-container" style="overflow-x: auto; overflow-y: auto; max-height: 50vh; border: 1px solid #e0e0e0; border-radius: 4px;">
        <table id="locations-table">
            <thead>
                <tr>
                    <th class="sortable" data-sort="loc_id">ID <span class="sort-indicator"></span></th>
                    <th>Location</th>
                    <th class="sortable" data-sort="loc_type">Type <span class="sort-indicator"></span></th>
                    <th class="sortable" data-sort="zone">Zone <span class="sort-indicator"></span></th>
                    <th class="sortable" data-sort="flag">Flag <span class="sort-indicator"></span></th>
                    <th>Operational Window</th>
                    <th class="sortable" data-sort="first_runner">First/Last Runner <span class="sort-indicator"></span></th>
                    <th>Peak Window</th>
                </tr>
            </thead>
            <tbody id="locations-tbody">
                <tr>
                    <td colspan="8" class="placeholder">Loading locations data...</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Locations Reference -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Locations Reference</h3>
    <p style="margin-bottom: 1rem; color: #666; font-size: 0.9rem;">
        Definitions for key metrics in the locations report.
    </p>
    <table>
        <thead>
            <tr>
                <th>Column</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Location</strong></td>
                <td>The name or label of the location (e.g., "Regent & McLeod").</td>
            </tr>
            <tr>
                <td><strong>Type</strong></td>
                <td>The location type: <em>traffic</em> (traffic control point), <em>course</em> (on-course location), <em>water</em> (water stop), <em>aid</em> (aid station), or <em>marshal</em> (marshal point).</td>
            </tr>
            <tr>
                <td><strong>Zone</strong></td>
                <td>A predefined operational area used to organize mobile first-aid responders and support personnel. A zone may include one or more course segments and is designed to improve coverage, communication, and response times along the course.</td>
            </tr>
            <tr>
                <td><strong>Flag</strong></td>
                <td>Indicates that this location is on—or near—a course segment that has been flagged for high density or flow concerns. Flags are derived from density analysis and may represent areas of congestion, crowding risk, or operational attention. In some cases, the location is linked via a nearby proxy point to the flagged segment.</td>
            </tr>
            <tr>
                <td><strong>Operational Window</strong></td>
                <td>The time window from <em>loc_start</em> to <em>loc_end</em>, indicating when resources should be deployed at this location. <em>loc_start</em> is 45 minutes before the earliest scheduled runner start time.</td>
            </tr>
            <tr>
                <td><strong>Peak Window</strong></td>
                <td>The time window from <em>peak_start</em> (25th percentile arrival) to <em>peak_end</em> (75th percentile arrival), representing when the majority of runners pass this location. For traffic locations, this will be null/NA.</td>
            </tr>
        </tbody>
    </table>
</div>

{% endblock %}

{% block extra_scripts %}
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- External JavaScript modules -->
<script src="/static/js/map/base_map.js"></script>
<script src="/static/js/map/locations.js?v=2025-12-14T0100Z"></script>

<!-- Table interaction script -->
<script>
    let locationsData = [];
    let tableDataLoaded = false;
    let currentSort = { column: null, direction: 'asc' }; // 'asc' or 'desc'
    
    // Load locations data on page load (only if map hasn't loaded it yet)
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize filter event listeners
        initializeFilters();
        
        // Initialize sortable headers
        initializeSorting();
        
        // Wait a bit to see if map script loads data first
        setTimeout(() => {
            if (!tableDataLoaded) {
                loadLocationsData();
            }
        }, 200);
    });
    
    function loadLocationsData() {
        // Get run_id and day from URL or global state
        const params = new URLSearchParams(window.location.search);
        const dayParam = params.get('day');
        const runParam = params.get('run_id');
        
        const day = (dayParam || (window.runflowDay && window.runflowDay.selected) || '').toLowerCase().trim();
        const run_id = (runParam || (window.runflowDay && window.runflowDay.run_id) || '').trim();
        
        if (!day || !run_id) {
            console.error('❌ Refusing to fetch locations data without day+run_id', {
                href: window.location.href,
                dayParam, runParam,
                runflowDay: window.runflowDay
            });
            showLocationsError('Failed to load locations data: missing day or run_id');
            return;
        }
        
        const apiUrl = `/api/locations?run_id=${encodeURIComponent(run_id)}&day=${encodeURIComponent(day)}`;
        console.log('Loading locations data via API...', { apiUrl, day, run_id });
        
        fetch(apiUrl, { cache: 'no-store' })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.ok && data.locations) {
                    locationsData = data.locations;
                    
                    // Debug: Check first_runner and last_runner in first location
                    if (data.locations.length > 0) {
                        console.log('Sample location data:', {
                            loc_id: data.locations[0].loc_id,
                            first_runner: data.locations[0].first_runner,
                            last_runner: data.locations[0].last_runner,
                            first_runner_type: typeof data.locations[0].first_runner,
                            last_runner_type: typeof data.locations[0].last_runner
                        });
                    }
                    
                    // Populate filter dropdowns
                    populateTypeFilter(data.locations);
                    populateZoneFilter(data.locations);
                    // Issue #591: Populate resource filter from API response
                    if (data.resources_available) {
                        populateResourceFilter(data.resources_available);
                    }
                    
                    // Apply filters and render
                    applyFiltersAndRender();
                    
                    tableDataLoaded = true;
                } else {
                    showLocationsError('Invalid response format');
                }
            })
            .catch(error => {
                console.error('Error loading locations data:', error);
                showLocationsError('Failed to load locations data');
            });
    }
    
    /**
     * Update locations table with data (called from locations.js after map renders)
     * @param {Array} features - GeoJSON features array
     * @param {boolean} skipZoneRepopulation - If true, skip zone dropdown repopulation (for map bounds filtering)
     */
    function updateLocationsTable(features, skipZoneRepopulation = false) {
        if (!features || features.length === 0) {
            return;
        }
        
        // Mark that data has been loaded to prevent duplicate loading
        tableDataLoaded = true;
        
        // Convert features back to locations format for table rendering
        // Issue #483: Include first_runner and last_runner
        // Issue #591: Include resource count and mins fields dynamically
        const locations = features.map(feature => {
            const location = {
                loc_id: feature.properties.loc_id,
                loc_label: feature.properties.loc_label,
                loc_type: feature.properties.loc_type,
                zone: feature.properties.zone,
                loc_start: feature.properties.loc_start,
                loc_end: feature.properties.loc_end,
                duration: feature.properties.duration,
                peak_start: feature.properties.peak_start,
                peak_end: feature.properties.peak_end,
                timing_source: feature.properties.timing_source,
                first_runner: feature.properties.first_runner,
                last_runner: feature.properties.last_runner
            };
            // Issue #591: Dynamically add all resource count and mins fields
            // Issue #598: Include flag fields
            Object.keys(feature.properties).forEach(key => {
                if (key.endsWith('_count') || key.endsWith('_mins') || key === 'flag' || key === 'flagged_seg_id' || key === 'flag_severity' || key === 'flag_worst_los' || key === 'flag_note') {
                    location[key] = feature.properties[key];
                }
            });
            return location;
        });
        
        // Store for later use (only update if this is new data, not filtered subset)
        const isNewData = !locationsData || locations.length >= locationsData.length;
        if (isNewData) {
            locationsData = locations;
        }
        
        // Populate filter dropdowns only if new data or explicitly requested
        if (!skipZoneRepopulation && isNewData) {
            populateTypeFilter(locations);
            populateZoneFilter(locations);
        }
        
        // Apply current filters and render
        // If skipZoneRepopulation is true, this is from map bounds filtering - don't fit bounds
        applyFiltersAndRender(!skipZoneRepopulation);
    }
    
    /**
     * Update locations table with filtered features (from map bounds) - skips zone repopulation
     * @param {Array} features - GeoJSON features array
     */
    function updateLocationsTableFiltered(features) {
        if (!features || features.length === 0) {
            // If no features visible, render empty table
            renderLocationsTable([]);
            return;
        }
        
        // Convert features to locations format
        // Issue #591: Include resource count and mins fields dynamically
        const locations = features.map(feature => {
            const location = {
                loc_id: feature.properties.loc_id,
                loc_label: feature.properties.loc_label,
                loc_type: feature.properties.loc_type,
                zone: feature.properties.zone,
                loc_start: feature.properties.loc_start,
                loc_end: feature.properties.loc_end,
                duration: feature.properties.duration,
                peak_start: feature.properties.peak_start,
                peak_end: feature.properties.peak_end,
                timing_source: feature.properties.timing_source,
                first_runner: feature.properties.first_runner,
                last_runner: feature.properties.last_runner
            };
            // Issue #591: Dynamically add all resource count and mins fields
            // Issue #598: Include flag fields
            Object.keys(feature.properties).forEach(key => {
                if (key.endsWith('_count') || key.endsWith('_mins') || key === 'flag' || key === 'flagged_seg_id' || key === 'flag_severity' || key === 'flag_worst_los' || key === 'flag_note') {
                    location[key] = feature.properties[key];
                }
            });
            return location;
        });
        
        // Apply UI filters (Type, Zone, Resource, Flag, First Runner, Last Runner) to the map-bounds-filtered locations
        const typeFilter = document.getElementById('filter-type')?.value || '';
        const zoneFilter = document.getElementById('filter-zone')?.value || '';
        const resourceFilter = document.getElementById('filter-resource')?.value || '';  // Issue #591
        const flagFilter = document.getElementById('filter-flag')?.value || '';  // Issue #598
        const lastRunnerMin = document.getElementById('filter-last-runner-min')?.value || '';
        const lastRunnerMax = document.getElementById('filter-last-runner-max')?.value || '';
        
        let filtered = locations.filter(location => {
            // Type filter
            if (typeFilter && location.loc_type !== typeFilter) {
                return false;
            }
            
            // Zone filter - compare as numbers to handle type coercion
            if (zoneFilter) {
                const locationZone = location.zone != null ? Number(location.zone) : null;
                const filterZone = Number(zoneFilter);
                if (locationZone !== filterZone) {
                    return false;
                }
            }
            
            // Issue #591: Resource filter - check if location has count > 0 for selected resource
            if (resourceFilter) {
                const countField = `${resourceFilter}_count`;
                const locationCount = location[countField];
                // Check if count exists and is greater than 0
                if (!locationCount || locationCount === 0 || locationCount === "0" || locationCount === null || locationCount === undefined) {
                    return false;
                }
            }
            
            // Issue #598: Flag filter
            if (flagFilter) {
                const locationFlag = location.flag;
                const flagValue = locationFlag === true || locationFlag === "true" || locationFlag === "Y" ? "Y" : "N";
                if (flagValue !== flagFilter) {
                    return false;
                }
            }
            
            // Last Runner filter
            const lastRunnerHHMM = timeToHHMM(location.last_runner);
            if (lastRunnerMin && (!lastRunnerHHMM || lastRunnerHHMM < lastRunnerMin)) {
                return false;
            }
            if (lastRunnerMax && (!lastRunnerHHMM || lastRunnerHHMM > lastRunnerMax)) {
                return false;
            }
            
            return true;
        });
        
        // Apply sorting
        if (currentSort.column) {
            filtered = sortLocations(filtered, currentSort.column, currentSort.direction);
        } else {
            // Default sort by loc_id
            filtered.sort((a, b) => {
                const idA = a.loc_id || 0;
                const idB = b.loc_id || 0;
                return idA - idB;
            });
        }
        
        // Update map markers (without fitting bounds - preserve user zoom)
        filterMapToLocations(filtered.map(loc => loc.loc_id), false);
        
        // Render filtered and sorted data
        renderLocationsTable(filtered);
    }
    
    /**
     * Helper function to format time from hh:mm:ss to hh:mm
     * @param {string|null} timeStr - Time string in hh:mm:ss or hh:mm format
     * @returns {string|null} Formatted time in hh:mm or null
     */
    function formatTimeToHHMM(timeStr) {
        if (!timeStr || timeStr === "NA") return null;
        // If already in hh:mm format, return as-is
        if (timeStr.match(/^\d{2}:\d{2}$/)) return timeStr;
        // If in hh:mm:ss format, drop seconds
        if (timeStr.match(/^\d{2}:\d{2}:\d{2}$/)) {
            return timeStr.substring(0, 5); // Take first 5 characters (hh:mm)
        }
        return timeStr; // Fallback: return original if format unexpected
    }
    
    /**
     * Convert HH:MM:SS or HH:MM to HHMM format (for filtering)
     * @param {string|null} timeStr - Time string
     * @returns {string|null} Time in HHMM format or null
     */
    function timeToHHMM(timeStr) {
        if (!timeStr || timeStr === "NA") return null;
        // Remove colons
        return timeStr.replace(/:/g, '');
    }
    
    /**
     * Convert HHMM to HH:MM format (for display)
     * @param {string|null} hhmmStr - Time in HHMM format
     * @returns {string|null} Time in HH:MM format or null
     */
    function hhmmToHHMM(hhmmStr) {
        if (!hhmmStr || hhmmStr.length !== 4) return null;
        return hhmmStr.substring(0, 2) + ':' + hhmmStr.substring(2, 4);
    }
    
    let zoneFilterPopulated = false;
    let typeFilterPopulated = false;
    let resourceFilterPopulated = false;  // Issue #591
    
    /**
     * Populate type filter dropdown with unique types
     * @param {Array} locations - Array of location objects
     */
    function populateTypeFilter(locations) {
        const typeSelect = document.getElementById('filter-type');
        if (!typeSelect) return;
        
        // Don't repopulate if dropdown is currently open (has focus)
        if (document.activeElement === typeSelect) {
            return;
        }
        
        // Get unique types
        const types = [...new Set(locations.map(loc => loc.loc_type).filter(t => t != null && t !== "NA" && t !== ""))].sort();
        
        // Only populate if dropdown hasn't been populated yet, or if types have changed
        const existingTypes = Array.from(typeSelect.options)
            .slice(1) // Skip "All Types" option
            .map(opt => opt.value)
            .sort();
        
        const typesMatch = existingTypes.length === types.length && 
            existingTypes.every((t, i) => t === types[i]);
        
        if (typeFilterPopulated && typesMatch) {
            // Already populated with same types, don't reset
            return;
        }
        
        // Preserve currently selected value
        const currentValue = typeSelect.value;
        
        // Clear existing options except "All Types"
        typeSelect.innerHTML = '<option value="">All Types</option>';
        
        // Add type options
        types.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type.charAt(0).toUpperCase() + type.slice(1); // Capitalize first letter
            typeSelect.appendChild(option);
        });
        
        // Restore previously selected value if it still exists
        if (currentValue && types.includes(currentValue)) {
            typeSelect.value = currentValue;
        }
        
        typeFilterPopulated = true;
    }
    
    /**
     * Populate resource filter dropdown with available resources (Issue #591)
     * @param {Array} resources - Array of resource prefixes (e.g., ["fpf", "awp", "yssr"])
     */
    function populateResourceFilter(resources) {
        const resourceSelect = document.getElementById('filter-resource');
        if (!resourceSelect) {
            // Function called before DOM is ready, skip
            return;
        }
        
        // Don't repopulate if dropdown is currently open (has focus)
        if (document.activeElement === resourceSelect) {
            return;
        }
        
        // Only populate if dropdown hasn't been populated yet, or if resources have changed
        const existingResources = Array.from(resourceSelect.options)
            .slice(1) // Skip "All Resources" option
            .map(opt => opt.value)
            .sort();
        
        const resourcesMatch = existingResources.length === resources.length && 
            existingResources.every((r, i) => r === resources[i]);
        
        if (resourceFilterPopulated && resourcesMatch) {
            // Already populated with same resources, don't reset
            return;
        }
        
        // Preserve currently selected value
        const currentValue = resourceSelect.value;
        
        // Clear existing options except "All Resources"
        resourceSelect.innerHTML = '<option value="">All Resources</option>';
        
        // Add resource options
        resources.forEach(resource => {
            const option = document.createElement('option');
            option.value = resource;
            option.textContent = resource.toUpperCase(); // Display in uppercase for readability
            resourceSelect.appendChild(option);
        });
        
        // Restore previously selected value if it still exists
        if (currentValue && resources.includes(currentValue)) {
            resourceSelect.value = currentValue;
        }
        
        resourceFilterPopulated = true;
    }
    
    // Issue #591: Make populateResourceFilter globally available for locations.js
    window.populateResourceFilter = populateResourceFilter;
    
    // Issue #591: Populate resource filter if pending data exists (from map script loading first)
    // Check immediately, and also check after a delay in case map script loads after page load
    if (window.pendingResourcesAvailable) {
        populateResourceFilter(window.pendingResourcesAvailable);
        delete window.pendingResourcesAvailable;
    } else {
        // Also check after a delay in case locations.js loads data after this script runs
        setTimeout(() => {
            if (window.pendingResourcesAvailable && typeof populateResourceFilter === 'function') {
                populateResourceFilter(window.pendingResourcesAvailable);
                delete window.pendingResourcesAvailable;
            }
        }, 1000);
    }
    
    /**
     * Populate zone filter dropdown with unique zones
     * @param {Array} locations - Array of location objects
     */
    function populateZoneFilter(locations) {
        const zoneSelect = document.getElementById('filter-zone');
        if (!zoneSelect) return;
        
        // Don't repopulate if dropdown is currently open (has focus)
        if (document.activeElement === zoneSelect) {
            // Silently skip - don't log to reduce console noise
            return;
        }
        
        // Get unique zones
        const zones = [...new Set(locations.map(loc => loc.zone).filter(z => z != null && z !== "NA" && z !== ""))].sort((a, b) => a - b);
        
        // Only populate if dropdown hasn't been populated yet, or if zones have changed
        const existingZones = Array.from(zoneSelect.options)
            .slice(1) // Skip "All Zones" option
            .map(opt => Number(opt.value))
            .sort((a, b) => a - b);
        
        const zonesMatch = existingZones.length === zones.length && 
            existingZones.every((z, i) => z === zones[i]);
        
        if (zoneFilterPopulated && zonesMatch) {
            // Already populated with same zones, don't reset
            return;
        }
        
        // Preserve currently selected value
        const currentValue = zoneSelect.value;
        
        // Clear existing options except "All Zones"
        zoneSelect.innerHTML = '<option value="">All Zones</option>';
        
        // Add zone options
        zones.forEach(zone => {
            const option = document.createElement('option');
            option.value = zone;
            option.textContent = zone;
            zoneSelect.appendChild(option);
        });
        
        // Restore previously selected value if it still exists
        if (currentValue && zones.includes(Number(currentValue))) {
            zoneSelect.value = currentValue;
        }
        
        zoneFilterPopulated = true;
    }
    
    /**
     * Apply filters and render table (Issue #483)
     * Also updates map to show only filtered locations
     * @param {boolean} fitBounds - Whether to fit map bounds to filtered locations (default: true)
     */
    function applyFiltersAndRender(fitBounds = true) {
        if (!locationsData || locationsData.length === 0) {
            return;
        }
        
        // Get filter values
        const typeFilter = document.getElementById('filter-type')?.value || '';
        const zoneFilter = document.getElementById('filter-zone')?.value || '';
        const resourceFilter = document.getElementById('filter-resource')?.value || '';  // Issue #591
        const flagFilter = document.getElementById('filter-flag')?.value || '';  // Issue #598
        const lastRunnerMin = document.getElementById('filter-last-runner-min')?.value || '';
        const lastRunnerMax = document.getElementById('filter-last-runner-max')?.value || '';
        
        // Filter locations
        let filtered = locationsData.filter(location => {
            // Type filter
            if (typeFilter && location.loc_type !== typeFilter) {
                return false;
            }
            
            // Zone filter - compare as numbers to handle type coercion
            if (zoneFilter) {
                const locationZone = location.zone != null ? Number(location.zone) : null;
                const filterZone = Number(zoneFilter);
                if (locationZone !== filterZone) {
                    return false;
                }
            }
            
            // Issue #591: Resource filter - check if location has count > 0 for selected resource
            if (resourceFilter) {
                const countField = `${resourceFilter}_count`;
                const locationCount = location[countField];
                // Check if count exists and is greater than 0
                if (!locationCount || locationCount === 0 || locationCount === "0" || locationCount === null || locationCount === undefined) {
                    return false;
                }
            }
            
            // Last Runner filter
            const lastRunnerHHMM = timeToHHMM(location.last_runner);
            if (lastRunnerMin && (!lastRunnerHHMM || lastRunnerHHMM < lastRunnerMin)) {
                return false;
            }
            if (lastRunnerMax && (!lastRunnerHHMM || lastRunnerHHMM > lastRunnerMax)) {
                return false;
            }
            
            return true;
        });
        
        // Apply sorting
        if (currentSort.column) {
            filtered = sortLocations(filtered, currentSort.column, currentSort.direction);
        } else {
            // Default sort by loc_id
            filtered.sort((a, b) => {
                const idA = a.loc_id || 0;
                const idB = b.loc_id || 0;
                return idA - idB;
            });
        }
        
        // Update map to show only filtered locations (only fit bounds if requested)
        filterMapToLocations(filtered.map(loc => loc.loc_id), fitBounds);
        
        // Render filtered and sorted data
        renderLocationsTable(filtered);
    }
    
    /**
     * Filter map markers to show only specified location IDs
     * @param {Array<number|string>} visibleLocIds - Array of location IDs to show
     * @param {boolean} fitBounds - Whether to fit map bounds to visible markers (default: true)
     */
    function filterMapToLocations(visibleLocIds, fitBounds = true) {
        if (!window.locationsLayer || !window.locationsMarkersByLocId) {
            return; // Map not initialized yet
        }
        
        const visibleSet = new Set(visibleLocIds.map(id => String(id)));
        let hasVisibleMarkers = false;
        
        // Show/hide markers based on filter
        window.locationsLayer.eachLayer(function(marker) {
            const locId = String(marker.feature?.properties?.loc_id);
            const isVisible = visibleSet.has(locId);
            
            if (isVisible) {
                hasVisibleMarkers = true;
                // Show marker with original styling
                const props = marker.feature?.properties || {};
                const locType = props.loc_type?.toLowerCase() || 'unknown';
                const color = getLocationMarkerColor(locType);
                
                marker.setStyle({
                    radius: 8,
                    fillColor: color,
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                });
                
                // Re-enable pointer events so tooltips/popups work
                if (marker.options) {
                    marker.options.interactive = true;
                }
                marker._path && (marker._path.style.pointerEvents = 'auto');
            } else {
                // Hide marker by making it transparent and disabling pointer events
                marker.setStyle({
                    opacity: 0,
                    fillOpacity: 0
                });
                
                // Disable pointer events to prevent tooltip/popup on hidden markers
                if (marker.options) {
                    marker.options.interactive = false;
                }
                marker._path && (marker._path.style.pointerEvents = 'none');
            }
        });
        
        // Fit map bounds to visible markers if requested and if any visible
        if (fitBounds && hasVisibleMarkers && visibleLocIds.length > 0) {
            const visibleMarkers = visibleLocIds
                .map(id => window.locationsMarkersByLocId[String(id)])
                .filter(m => m != null);
            
            if (visibleMarkers.length > 0) {
                const group = L.featureGroup(visibleMarkers);
                if (window.map && group.getBounds().isValid()) {
                    // Temporarily disable bounds filtering to allow programmatic fit
                    const wasProgrammatic = window.isProgrammaticMapMove;
                    window.isProgrammaticMapMove = true;
                    
                    window.map.fitBounds(group.getBounds(), {
                        padding: [20, 20],
                        maxZoom: 16
                    });
                    
                    // Re-enable bounds filtering after animation
                    setTimeout(() => {
                        window.isProgrammaticMapMove = wasProgrammatic;
                    }, 600);
                }
            }
        }
    }
    
    /**
     * Get location marker color (helper function for map filtering)
     * @param {string} locType - Location type
     * @returns {string} Color hex code
     */
    function getLocationMarkerColor(locType) {
        const locationTypeColors = {
            'traffic': '#808080',  // Gray
            'course': '#2196F3',   // Blue
            'aid': '#F44336',      // Red
            'water': '#4CAF50',    // Green
            'marshal': '#FF9800'   // Orange
        };
        return locationTypeColors[locType?.toLowerCase()] || '#999999';
    }
    
    /**
     * Sort locations array
     * @param {Array} locations - Array of location objects
     * @param {string} column - Column to sort by
     * @param {string} direction - 'asc' or 'desc'
     * @returns {Array} Sorted array
     */
    function sortLocations(locations, column, direction) {
        const sorted = [...locations];
        
        sorted.sort((a, b) => {
            let aVal, bVal;
            
            switch(column) {
                case 'loc_id':
                    aVal = a.loc_id != null && a.loc_id !== undefined ? Number(a.loc_id) : Infinity;
                    bVal = b.loc_id != null && b.loc_id !== undefined ? Number(b.loc_id) : Infinity;
                    break;
                case 'loc_type':
                    aVal = (a.loc_type && a.loc_type !== "NA") ? a.loc_type.toLowerCase() : '';
                    bVal = (b.loc_type && b.loc_type !== "NA") ? b.loc_type.toLowerCase() : '';
                    break;
                case 'zone':
                    aVal = a.zone != null && a.zone !== "NA" && a.zone !== "" ? Number(a.zone) : Infinity;
                    bVal = b.zone != null && b.zone !== "NA" && b.zone !== "" ? Number(b.zone) : Infinity;
                    break;
                case 'first_runner':
                    aVal = timeToHHMM(a.first_runner) || '';
                    bVal = timeToHHMM(b.first_runner) || '';
                    break;
                case 'last_runner':
                    aVal = timeToHHMM(a.last_runner) || '';
                    bVal = timeToHHMM(b.last_runner) || '';
                    break;
                case 'flag':
                    aVal = (a.flag === true || a.flag === "true" || a.flag === "Y") ? "Y" : "N";
                    bVal = (b.flag === true || b.flag === "true" || b.flag === "Y") ? "Y" : "N";
                    break;
                default:
                    return 0;
            }
            
            if (aVal < bVal) return direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return direction === 'asc' ? 1 : -1;
            return 0;
        });
        
        return sorted;
    }
    
    /**
     * Initialize filter event listeners (Issue #483)
     */
    function initializeFilters() {
        // Type filter
        const typeFilter = document.getElementById('filter-type');
        if (typeFilter) {
            typeFilter.addEventListener('change', function(e) {
                setTimeout(() => {
                    applyFiltersAndRender();
                }, 10);
            });
        }
        
        // Zone filter
        const zoneFilter = document.getElementById('filter-zone');
        if (zoneFilter) {
            // Use 'change' event which fires after selection is made
            zoneFilter.addEventListener('change', function(e) {
                // Small delay to ensure value is set before filtering
                setTimeout(() => {
                    applyFiltersAndRender();
                }, 10);
            });
        }
        
        // Issue #591: Resource filter
        const resourceFilter = document.getElementById('filter-resource');
        if (resourceFilter) {
            resourceFilter.addEventListener('change', function(e) {
                setTimeout(() => {
                    applyFiltersAndRender();
                }, 10);
            });
        }
        
        // Issue #598: Flag filter
        const flagFilter = document.getElementById('filter-flag');
        if (flagFilter) {
            flagFilter.addEventListener('change', function(e) {
                setTimeout(() => {
                    applyFiltersAndRender();
                }, 10);
            });
        }
        
        // Last Runner filters
        const lastRunnerMin = document.getElementById('filter-last-runner-min');
        const lastRunnerMax = document.getElementById('filter-last-runner-max');
        if (lastRunnerMin) {
            lastRunnerMin.addEventListener('input', function(e) {
                const value = e.target.value.replace(/\D/g, '');
                e.target.value = value;
                applyFiltersAndRender();
            });
        }
        if (lastRunnerMax) {
            lastRunnerMax.addEventListener('input', function(e) {
                const value = e.target.value.replace(/\D/g, '');
                e.target.value = value;
                applyFiltersAndRender();
            });
        }
        
        // Clear filters button
        const clearFiltersBtn = document.getElementById('clear-filters-btn');
        if (clearFiltersBtn) {
            clearFiltersBtn.addEventListener('click', function() {
                if (typeFilter) typeFilter.value = '';
                if (zoneFilter) zoneFilter.value = '';
                const resourceFilter = document.getElementById('filter-resource');  // Issue #591
                if (resourceFilter) resourceFilter.value = '';
                const flagFilter = document.getElementById('filter-flag');  // Issue #598
                if (flagFilter) flagFilter.value = '';
                if (lastRunnerMin) lastRunnerMin.value = '';
                if (lastRunnerMax) lastRunnerMax.value = '';
                
                // Clear single-location map filter if active
                if (window.clearMapFilter) {
                    window.clearMapFilter();
                }
                
                // Apply filters (will show all locations since filters are cleared)
                applyFiltersAndRender();
            });
        }
    }
    
    /**
     * Initialize sorting functionality (Issue #483)
     */
    function initializeSorting() {
        const sortableHeaders = document.querySelectorAll('#locations-table th.sortable');
        sortableHeaders.forEach(header => {
            header.style.cursor = 'pointer';
            header.addEventListener('click', function() {
                const column = this.getAttribute('data-sort');
                if (!column) return;
                
                // Toggle sort direction if same column
                if (currentSort.column === column) {
                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort.column = column;
                    currentSort.direction = 'asc';
                }
                
                // Update sort indicators
                updateSortIndicators();
                
                // Apply sorting
                applyFiltersAndRender();
            });
        });
    }
    
    /**
     * Update sort indicators in table headers
     */
    function updateSortIndicators() {
        const sortableHeaders = document.querySelectorAll('#locations-table th.sortable');
        sortableHeaders.forEach(header => {
            const indicator = header.querySelector('.sort-indicator');
            const column = header.getAttribute('data-sort');
            
            if (indicator) {
                if (currentSort.column === column) {
                    indicator.textContent = currentSort.direction === 'asc' ? ' ▲' : ' ▼';
                    indicator.style.color = '#007bff';
                } else {
                    indicator.textContent = '';
                }
            }
        });
    }
    
    function renderLocationsTable(locations) {
        const tbody = document.getElementById('locations-tbody');
        tbody.innerHTML = '';
        
        if (!locations || locations.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" class="placeholder">No locations data available</td></tr>';
            return;
        }
        
        locations.forEach(location => {
            const row = document.createElement('tr');
            
            // Format values with fallback to "—" for null/NA
            const locLabel = location.loc_label || "—";
            
            // Format location type
            const locType = location.loc_type && location.loc_type !== "NA" ? location.loc_type : "—";
            
            // Format operational window (loc_start → loc_end)
            const locStart = location.loc_start && location.loc_start !== "NA" ? location.loc_start : null;
            const locEnd = location.loc_end && location.loc_end !== "NA" ? location.loc_end : null;
            const locStartFormatted = formatTimeToHHMM(locStart);
            const locEndFormatted = formatTimeToHHMM(locEnd);
            const operationalWindow = (locStartFormatted && locEndFormatted) ? `${locStartFormatted} → ${locEndFormatted}` : "—";
            
            // Format peak window (peak_start → peak_end)
            const peakStart = location.peak_start && location.peak_start !== "NA" ? location.peak_start : null;
            const peakEnd = location.peak_end && location.peak_end !== "NA" ? location.peak_end : null;
            const peakStartFormatted = formatTimeToHHMM(peakStart);
            const peakEndFormatted = formatTimeToHHMM(peakEnd);
            const peakWindow = (peakStartFormatted && peakEndFormatted) ? `${peakStartFormatted} → ${peakEndFormatted}` : "—";
            
            // Get loc_id
            const locId = location.loc_id !== null && location.loc_id !== undefined ? location.loc_id : "—";
            
            // Format zone
            const zone = location.zone && location.zone !== "NA" && location.zone !== "" ? location.zone : "—";
            
            // Format First/Last Runner (Issue #592: Combined column)
            // Handle null, undefined, "NA", or empty string
            const firstRunnerRaw = location.first_runner;
            const firstRunnerFormatted = (firstRunnerRaw && firstRunnerRaw !== "NA" && firstRunnerRaw !== "null") 
                ? formatTimeToHHMM(firstRunnerRaw) || "—"
                : "—";
            
            const lastRunnerRaw = location.last_runner;
            const lastRunnerFormatted = (lastRunnerRaw && lastRunnerRaw !== "NA" && lastRunnerRaw !== "null")
                ? formatTimeToHHMM(lastRunnerRaw) || "—"
                : "—";
            
            // Combine First/Last Runner into single column (Issue #592)
            const firstLastRunner = (firstRunnerFormatted !== "—" && lastRunnerFormatted !== "—")
                ? `${firstRunnerFormatted} → ${lastRunnerFormatted}`
                : "—";
            
            // Issue #598: Format flag value
            const flagValue = location.flag === true || location.flag === "true" || location.flag === "Y" ? "Y" : "N";
            const flagDisplay = flagValue;
            
            // Updated table structure - includes Type column, Flag column, combined First/Last Runner
            // Column order: ID, Location, Type, Zone, Flag, Operational Window, First/Last Runner, Peak Window
            row.innerHTML = `
                <td>${locId}</td>
                <td>${locLabel}</td>
                <td>${locType}</td>
                <td>${zone}</td>
                <td>${flagDisplay}</td>
                <td>${operationalWindow}</td>
                <td>${firstLastRunner}</td>
                <td>${peakWindow}</td>
            `;
            
            // Add click handler for table-to-map filtering
            row.addEventListener('click', function() {
                const locationId = location.loc_id;
                
                // Check if this row is already selected
                if (row.classList.contains('selected-row')) {
                    // If already selected, clear the filter
                    if (window.clearMapFilter) {
                        window.clearMapFilter();
                    }
                } else {
                    // If not selected, filter map to this location
                    if (window.filterMapToLocation) {
                        window.filterMapToLocation(locationId);
                    }
                }
            });
            
            // Add hover effects
            row.addEventListener('mouseenter', function() {
                if (!row.classList.contains('selected-row')) {
                    row.style.backgroundColor = '#f5f5f5';
                }
            });
            
            row.addEventListener('mouseleave', function() {
                if (!row.classList.contains('selected-row')) {
                    row.style.backgroundColor = '';
                }
            });
            
            tbody.appendChild(row);
        });
    }
    
    function showLocationsError(message) {
        const tbody = document.getElementById('locations-tbody');
        tbody.innerHTML = `<tr><td colspan="8" class="placeholder">${message}</td></tr>`;
    }
    
    // Make updateLocationsTable globally available for locations.js
    window.updateLocationsTable = updateLocationsTable;
    window.updateLocationsTableFiltered = updateLocationsTableFiltered;
</script>

<style>
    /* Table row highlighting */
    #locations-table tr.selected-row {
        background-color: #e3f2fd !important;
        border-left: 4px solid #2196f3;
    }
    
    #locations-table tbody tr {
        cursor: pointer;
    }
    
    #locations-table tbody tr:hover {
        background-color: #f8f9fa;
    }
</style>
{% endblock %}

{% block extra_styles %}
<style>
    #locations-table {
        width: 100%;
        border-collapse: collapse;
    }
    
    /* Match base template styling for consistency with Flow table */
    #locations-table th,
    #locations-table td {
        padding: 0.875rem 1rem;  /* Match base template: px-4 py-3 equivalent */
        text-align: left;
        border-bottom: 1px solid #e0e0e0;  /* Match base template border color */
    }
    
    #locations-table th {
        background: #f8f9fa;
        font-weight: 600;
        color: #2c3e50;
    }
    
    /* Sticky header for scrollable table (Issue #484) */
    #locations-table thead th {
        position: sticky;
        top: 0;
        background: #f8f9fa;
        z-index: 10;
        box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.1);
    }
    
    #locations-table tbody tr:hover {
        background: #f8f9fa;
    }
    
    /* Sortable column styling (Issue #483) */
    #locations-table th.sortable {
        cursor: pointer;
        user-select: none;
        position: relative;
    }
    
    #locations-table th.sortable:hover {
        background: #e9ecef;
    }
    
    #locations-table th.sortable .sort-indicator {
        color: #007bff;
        font-size: 0.75rem;
        margin-left: 0.25rem;
    }
</style>
{% endblock %}

