{% extends "base.html" %}

{% block title %}Flow Analysis{% endblock %}

{% block content %}
<div class="page-header">
    <h2>Temporal Flow Analysis</h2>
    {% if meta %}
    {% endif %}
</div>

<!-- Flow Metrics Table -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Segment Flow Metrics</h3>
    <p style="margin-bottom: 1rem; color: #7f8c8d; font-size: 0.875rem;">
        Values are sums across all event pairs per segment from temporal flow analysis.
    </p>
    <div style="overflow-x: auto;">
        <table id="flow-table">
            <thead>
                <tr>
                    <th></th> <!-- Expand/collapse icon -->
                    <th>ID</th>
                    <th>NAME</th>
                    <th>EVENT</th>
                    <th>FLOW TYPE</th>
                    <th>WORST ZONE</th>
                    <th class="sortable" data-sort="overtaking">OVERTAKING <span class="sort-indicator"></span></th>
                    <th>PCT</th>
                    <th class="sortable" data-sort="copresence">CO-PRESENCE <span class="sort-indicator"></span></th>
                </tr>
            </thead>
            <tbody id="flow-tbody">
                <tr>
                    <td colspan="9" class="placeholder">Loading flow data...</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Flow Reference -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Flow Reference</h3>
    <p style="margin-bottom: 1rem; color: #666; font-size: 0.9rem;">
        Definitions for key metrics in the temporal flow analysis.
    </p>
    <table>
        <thead>
            <tr>
                <th>Column</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Event A / Event B</strong></td>
                <td>The two event cohorts being compared (e.g., Full vs Half Marathon). Each pair shows interactions between participants from these events along a segment.</td>
            </tr>
            <tr>
                <td><strong>Flow Type</strong></td>
                <td>Indicates the interaction pattern between the two events:<br>
                • <em>Overtake</em>: Participants in one event pass another.<br>
                • <em>Parallel</em>: Both events move in the same direction concurrently.<br>
                • <em>Counterflow</em>: Participants move in opposite directions on the same path.</td>
            </tr>
            <tr>
                <td><strong>Overtaking A / Overtaking B</strong></td>
                <td>The number of overtake events detected where runners in Event A (or B) passed participants from the paired event within that segment.</td>
            </tr>
            <tr>
                <td><strong>Pct A / Pct B</strong></td>
                <td>The percentage of participants from Event A (or B) involved in overtaking interactions relative to their total count on that segment.</td>
            </tr>
            <tr>
                <td><strong>Co-presence A / Co-presence B</strong></td>
                <td>The number of times participants from Event A and Event B occupied the same segment simultaneously (a measure of concurrent use or congestion).</td>
            </tr>
        </tbody>
    </table>
</div>

{% endblock %}

{% block extra_scripts %}
<script>
    let flowData = {};
    let currentSort = { column: null, direction: 'asc' }; // 'asc' or 'desc' (Issue #596: Fix - moved outside DOMContentLoaded)
    
    // Load flow data on page load
    document.addEventListener('DOMContentLoaded', function() {
        initializeSorting();
        loadFlowData();
    });
    
    function loadFlowData() {
        // Get run_id and day from URL or global state
        const params = new URLSearchParams(window.location.search);
        const dayParam = params.get('day');
        const runParam = params.get('run_id');
        
        const day = (dayParam || (window.runflowDay && window.runflowDay.selected) || '').toLowerCase().trim();
        const run_id = (runParam || (window.runflowDay && window.runflowDay.run_id) || '').trim();
        
        if (!day || !run_id) {
            console.error('❌ Refusing to fetch flow data without day+run_id', {
                href: window.location.href,
                dayParam, runParam,
                runflowDay: window.runflowDay
            });
            showFlowError();
            return;
        }
        
        const apiUrl = `/api/flow/segments?run_id=${encodeURIComponent(run_id)}&day=${encodeURIComponent(day)}`;
        console.log('Loading flow data via API...', { apiUrl, day, run_id });
        
        fetch(apiUrl, { cache: 'no-store' })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                // Handle new response format with selected_day/available_days
                const flow = data.flow || data;
                flowData = flow;
                renderFlowTable(flow);
            })
            .catch(error => {
                console.error('Error loading flow data:', error);
                showFlowError();
            });
    }
    
    function renderFlowTable(flow) {
        const tbody = document.getElementById('flow-tbody');
        tbody.innerHTML = '';
        
        const segments = Object.values(flow);
        
        if (!segments || segments.length === 0) {
            tbody.innerHTML = '<tr><td colspan="9" class="placeholder">No flow data available</td></tr>';
            return;
        }
        
        // Apply sorting if column is selected
        let sortedSegments = segments;
        if (currentSort.column) {
            sortedSegments = sortSegments(segments, currentSort.column, currentSort.direction);
        } else {
            // Default sort by seg_id
            sortedSegments = [...segments].sort((a, b) => (a.seg_id || '').localeCompare(b.seg_id || ''));
        }
        
        sortedSegments.forEach(segment => {
            // Issue #628: Use worst zone metrics from segment data
            const worstZone = segment.worst_zone || {};
            const worstZoneDisplay = worstZone.display || "—";
            
            // Get worst zone metrics or fallback to segment metrics
            const overtakingA = worstZone.overtaking_a !== null && worstZone.overtaking_a !== undefined ? worstZone.overtaking_a : (segment.overtaking_a !== null && segment.overtaking_a !== undefined ? segment.overtaking_a : 0);
            const overtakingB = worstZone.overtaking_b !== null && worstZone.overtaking_b !== undefined ? worstZone.overtaking_b : (segment.overtaking_b !== null && segment.overtaking_b !== undefined ? segment.overtaking_b : 0);
            const copresenceA = worstZone.copresence_a !== null && worstZone.copresence_a !== undefined ? worstZone.copresence_a : (segment.copresence_a !== null && segment.copresence_a !== undefined ? segment.copresence_a : 0);
            const copresenceB = worstZone.copresence_b !== null && worstZone.copresence_b !== undefined ? worstZone.copresence_b : (segment.copresence_b !== null && segment.copresence_b !== undefined ? segment.copresence_b : 0);
            const pctA = worstZone.pct_a !== null && worstZone.pct_a !== undefined ? worstZone.pct_a : (segment.pct_a !== null && segment.pct_a !== undefined ? segment.pct_a : 0);
            const pctB = worstZone.pct_b !== null && worstZone.pct_b !== undefined ? worstZone.pct_b : (segment.pct_b !== null && segment.pct_b !== undefined ? segment.pct_b : 0);
            
            // Format display values
            const eventA = segment.event_a || "—";
            const eventB = segment.event_b || "—";
            const overtakingADisplay = overtakingA > 0 ? overtakingA.toFixed(0) : "—";
            const overtakingBDisplay = overtakingB > 0 ? overtakingB.toFixed(0) : "—";
            const pctADisplay = pctA > 0 ? pctA.toFixed(1) + "%" : "—";
            const pctBDisplay = pctB > 0 ? pctB.toFixed(1) + "%" : "—";
            const copresenceADisplay = copresenceA > 0 ? copresenceA.toFixed(0) : "—";
            const copresenceBDisplay = copresenceB > 0 ? copresenceB.toFixed(0) : "—";
            
            // Create main segment row
            const row = document.createElement('tr');
            row.className = 'segment-row';
            row.dataset.segmentKey = `${segment.seg_id}_${segment.event_a}_${segment.event_b}`;
            
            row.innerHTML = `
                <td class="expand-icon" style="cursor: pointer; text-align: center; width: 30px;">
                    <span class="expand-symbol">▶</span>
                </td>
                <td>${segment.seg_id || "—"}</td>
                <td>${segment.segment_label || segment.name || "—"}</td>
                <td class="event-pair">${eventA} / ${eventB}</td>
                <td>${segment.flow_type || 'overtake'}</td>
                <td class="worst-zone" style="font-weight: 500;">${worstZoneDisplay}</td>
                <td class="numeric-pair">${overtakingADisplay} / ${overtakingBDisplay}</td>
                <td class="numeric-pair">${pctADisplay} / ${pctBDisplay}</td>
                <td class="numeric-pair">${copresenceADisplay} / ${copresenceBDisplay}</td>
            `;
            
            tbody.appendChild(row);
            
            // Issue #628: Add zone drilldown row (initially hidden)
            if (segment.zones && segment.zones.length > 0) {
                const zoneRow = document.createElement('tr');
                zoneRow.className = 'zone-drilldown-row';
                zoneRow.style.display = 'none';
                zoneRow.dataset.segmentKey = `${segment.seg_id}_${segment.event_a}_${segment.event_b}`;
                
                const zoneCell = document.createElement('td');
                zoneCell.colSpan = 9;
                zoneCell.className = 'zone-drilldown-cell';
                zoneCell.style.padding = '1rem';
                zoneCell.style.backgroundColor = '#f8f9fa';
                
                // Build zone table HTML
                zoneCell.innerHTML = buildZoneTable(segment.zones, segment);
                zoneRow.appendChild(zoneCell);
                tbody.appendChild(zoneRow);
                
                // Add click handler to expand/collapse
                row.querySelector('.expand-icon').addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleZoneDrilldown(row, zoneRow);
                });
                
                // Issue #628: Initialize zone table sorting after DOM is updated
                setTimeout(() => {
                    initializeZoneTableSorting(zoneCell, segment.zones, segment);
                }, 0);
            } else {
                // No zones - disable expand
                const expandIcon = row.querySelector('.expand-icon');
                expandIcon.style.cursor = 'default';
                expandIcon.style.opacity = '0.3';
            }
        });
        
        // Update sort indicators
        updateSortIndicators();
    }
    
    function toggleZoneDrilldown(segmentRow, zoneRow) {
        const isExpanded = zoneRow.style.display !== 'none';
        const expandSymbol = segmentRow.querySelector('.expand-symbol');
        
        if (isExpanded) {
            zoneRow.style.display = 'none';
            expandSymbol.textContent = '▶';
            expandSymbol.style.transform = 'rotate(0deg)';
        } else {
            zoneRow.style.display = '';
            expandSymbol.textContent = '▼';
            expandSymbol.style.transform = 'rotate(0deg)';
        }
    }
    
    function buildZoneTable(zones, segment) {
        if (!zones || zones.length === 0) {
            return '<p style="color: #666; font-style: italic;">No zone data available for this segment.</p>';
        }
        
        // Sort zones by zone_index
        const sortedZones = [...zones].sort((a, b) => (a.zone_index || 0) - (b.zone_index || 0));
        
        let html = '<div style="margin-bottom: 1rem;"><h4 style="margin: 0 0 0.75rem 0;">Zone-Level Details</h4></div>';
        html += '<div style="overflow-x: auto;"><table id="zone-table-' + segment.seg_id + '-' + segment.event_a + '-' + segment.event_b + '" class="zone-table">';
        html += '<thead><tr>';
        html += '<th class="sortable" data-sort="zone_index">Zone <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="cp_km">CP (km) <span class="sort-indicator"></span></th>';
        html += '<th>Type</th>';
        html += '<th class="sortable" data-sort="overtaking_a">Overtaking A <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="overtaking_b">Overtaking B <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="overtaken_a">Overtaken A <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="overtaken_b">Overtaken B <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="copresence_a">Co-presence A <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="copresence_b">Co-presence B <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="unique_encounters">Unique Encounters <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="participants_involved">Participants <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="multi_category_runners">Multi-category <span class="sort-indicator"></span></th>';
        html += '</tr></thead><tbody>';
        
        sortedZones.forEach(zone => {
            const caption = zone.caption || {};
            const captionSummary = caption.summary || '';
            
            html += '<tr class="zone-row">';
            html += '<td><strong>' + (zone.zone_index !== undefined ? zone.zone_index : '—') + '</strong></td>';
            html += '<td>' + (zone.cp_km !== undefined ? zone.cp_km.toFixed(2) : '—') + '</td>';
            html += '<td>' + (zone.cp_type || '—') + '</td>';
            html += '<td class="numeric">' + (zone.overtaking_a !== undefined ? zone.overtaking_a : '—') + '</td>';
            html += '<td class="numeric">' + (zone.overtaking_b !== undefined ? zone.overtaking_b : '—') + '</td>';
            html += '<td class="numeric">' + (zone.overtaken_a !== undefined ? zone.overtaken_a : '—') + '</td>';
            html += '<td class="numeric">' + (zone.overtaken_b !== undefined ? zone.overtaken_b : '—') + '</td>';
            html += '<td class="numeric">' + (zone.copresence_a !== undefined ? zone.copresence_a : '—') + '</td>';
            html += '<td class="numeric">' + (zone.copresence_b !== undefined ? zone.copresence_b : '—') + '</td>';
            html += '<td class="numeric">' + (zone.unique_encounters !== undefined ? zone.unique_encounters.toLocaleString() : '—') + '</td>';
            html += '<td class="numeric">' + (zone.participants_involved !== undefined ? zone.participants_involved : '—') + '</td>';
            html += '<td class="numeric">' + (zone.multi_category_runners !== undefined ? zone.multi_category_runners : '—') + '</td>';
            html += '</tr>';
            
            // Issue #628: Add caption row below zone row
            if (captionSummary) {
                html += '<tr class="zone-caption-row">';
                html += '<td colspan="12" style="padding: 0.75rem 1rem; background: #fff; border-bottom: 1px solid #e0e0e0;">';
                html += '<div style="font-size: 0.9rem; line-height: 1.5; color: #2c3e50; font-style: italic;">' + escapeHtml(captionSummary) + '</div>';
                html += '</td>';
                html += '</tr>';
            }
        });
        
        html += '</tbody></table></div>';
        
        return html;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function sortSegments(segments, column, direction) {
        const sorted = [...segments];
        
        sorted.sort((a, b) => {
            let aVal, bVal;
            
            // Issue #628: Use worst zone metrics for sorting
            const aWorstZone = a.worst_zone || {};
            const bWorstZone = b.worst_zone || {};
            
            switch (column) {
                case 'overtaking':
                    // Sort by worst zone overtaking sum
                    const aOvertaking = (aWorstZone.overtaking_a || a.overtaking_a || 0) + (aWorstZone.overtaking_b || a.overtaking_b || 0);
                    const bOvertaking = (bWorstZone.overtaking_a || b.overtaking_a || 0) + (bWorstZone.overtaking_b || b.overtaking_b || 0);
                    aVal = aOvertaking;
                    bVal = bOvertaking;
                    break;
                case 'copresence':
                    // Sort by worst zone copresence sum
                    const aCopresence = (aWorstZone.copresence_a || a.copresence_a || 0) + (aWorstZone.copresence_b || a.copresence_b || 0);
                    const bCopresence = (bWorstZone.copresence_a || b.copresence_a || 0) + (bWorstZone.copresence_b || b.copresence_b || 0);
                    aVal = aCopresence;
                    bVal = bCopresence;
                    break;
                default:
                    return 0;
            }
            
            if (aVal < bVal) return direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return direction === 'asc' ? 1 : -1;
            return 0;
        });
        
        return sorted;
    }
    
    function initializeSorting() {
        const sortableHeaders = document.querySelectorAll('#flow-table th.sortable');
        sortableHeaders.forEach(header => {
            header.style.cursor = 'pointer';
            header.addEventListener('click', function() {
                const column = this.getAttribute('data-sort');
                if (!column) return;
                
                // Toggle sort direction if same column
                if (currentSort.column === column) {
                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort.column = column;
                    currentSort.direction = 'asc';
                }
                
                // Re-render table with new sort
                if (flowData && Object.keys(flowData).length > 0) {
                    renderFlowTable(flowData);
                }
            });
        });
    }
    
    function updateSortIndicators() {
        const sortableHeaders = document.querySelectorAll('#flow-table th.sortable');
        sortableHeaders.forEach(header => {
            const indicator = header.querySelector('.sort-indicator');
            const column = header.getAttribute('data-sort');
            
            if (indicator) {
                if (currentSort.column === column) {
                    indicator.textContent = currentSort.direction === 'asc' ? ' ▲' : ' ▼';
                    indicator.style.color = '#007bff';
                } else {
                    indicator.textContent = '';
                }
            }
        });
    }
    
    function showFlowError() {
        const tbody = document.getElementById('flow-tbody');
        tbody.innerHTML = '<tr><td colspan="9" class="placeholder">Error loading flow data</td></tr>';
    }
</script>
{% endblock %}

{% block extra_styles %}
<style>
    #flow-table th.sortable {
        cursor: pointer;
        user-select: none;
        position: relative;
    }
    
    #flow-table th.sortable:hover {
        background: #e9ecef;
    }
    
    #flow-table th.sortable .sort-indicator {
        color: #007bff;
        font-size: 0.75rem;
        margin-left: 0.25rem;
    }
    
    #flow-table {
        width: 100%;
        border-collapse: collapse;
    }
    
    /* Match base template styling for consistency with Segments table */
    #flow-table th,
    #flow-table td {
        padding: 0.875rem 1rem;  /* Match base template: px-4 py-3 equivalent */
        text-align: left;
        border-bottom: 1px solid #e0e0e0;  /* Match base template border color */
    }
    
    #flow-table th {
        background: #f8f9fa;
        font-weight: 600;
        color: #2c3e50;
    }
    
    #flow-table tbody tr:hover {
        background: #f8f9fa;
    }
    
    /* Styling for merged A/B columns */
    td.numeric-pair {
        text-align: right;
        white-space: nowrap;
    }
    
    td.event-pair {
        white-space: nowrap;
    }
    
    td.numeric-pair span.separator {
        color: #9ca3af; /* Tailwind gray-400 equivalent */
        margin: 0 2px;
    }
    
    /* Issue #628: Accordion styling for zone drilldown */
    .expand-icon {
        user-select: none;
        transition: transform 0.2s;
    }
    
    .expand-icon:hover {
        color: #007bff;
    }
    
    .expand-symbol {
        display: inline-block;
        transition: transform 0.2s;
    }
    
    .segment-row {
        cursor: pointer;
    }
    
    .segment-row:hover {
        background: #f8f9fa;
    }
    
    .zone-drilldown-row {
        background: #f8f9fa;
    }
    
    .zone-drilldown-cell {
        padding: 1rem !important;
    }
    
    .zone-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
    }
    
    .zone-table th {
        background: #e9ecef;
        font-weight: 600;
        padding: 0.5rem 0.75rem;
        text-align: left;
        border-bottom: 2px solid #dee2e6;
    }
    
    .zone-table th.sortable {
        cursor: pointer;
        user-select: none;
    }
    
    .zone-table th.sortable:hover {
        background: #dee2e6;
    }
    
    .zone-table td {
        padding: 0.5rem 0.75rem;
        border-bottom: 1px solid #e0e0e0;
    }
    
    .zone-table tbody tr.zone-row:hover {
        background: #fff;
    }
    
    .zone-table td.numeric {
        text-align: right;
    }
    
    .zone-caption-row td {
        font-style: italic;
        color: #495057;
        padding: 0.75rem 1rem;
    }
    
    .worst-zone {
        color: #dc3545;
        font-weight: 500;
    }
</style>
{% endblock %}
