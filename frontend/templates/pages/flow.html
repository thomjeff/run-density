{% extends "base.html" %}

{% block title %}Flow Analysis{% endblock %}

{% block content %}
<div class="page-header">
    <h2>Temporal Flow Analysis</h2>
    {% if meta %}
    {% endif %}
</div>

<!-- Flow Metrics Table -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Segment Flow Metrics</h3>
    <p style="margin-bottom: 1rem; color: #7f8c8d; font-size: 0.875rem;">
        Values are sums across all event pairs per segment from temporal flow analysis.
    </p>
    <div style="overflow-x: auto;">
        <table id="flow-table">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>NAME</th>
                    <th>EVENT</th>
                    <th>FLOW TYPE</th>
                    <th class="sortable" data-sort="overtaking">OVERTAKING <span class="sort-indicator"></span></th>
                    <th>PCT</th>
                    <th class="sortable" data-sort="copresence">CO-PRESENCE <span class="sort-indicator"></span></th>
                </tr>
            </thead>
            <tbody id="flow-tbody">
                <tr>
                    <td colspan="7" class="placeholder">Loading flow data...</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Flow Reference -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Flow Reference</h3>
    <p style="margin-bottom: 1rem; color: #666; font-size: 0.9rem;">
        Definitions for key metrics in the temporal flow analysis.
    </p>
    <table>
        <thead>
            <tr>
                <th>Column</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Event A / Event B</strong></td>
                <td>The two event cohorts being compared (e.g., Full vs Half Marathon). Each pair shows interactions between participants from these events along a segment.</td>
            </tr>
            <tr>
                <td><strong>Flow Type</strong></td>
                <td>Indicates the interaction pattern between the two events:<br>
                • <em>Overtake</em>: Participants in one event pass another.<br>
                • <em>Parallel</em>: Both events move in the same direction concurrently.<br>
                • <em>Counterflow</em>: Participants move in opposite directions on the same path.</td>
            </tr>
            <tr>
                <td><strong>Overtaking A / Overtaking B</strong></td>
                <td>The number of overtake events detected where runners in Event A (or B) passed participants from the paired event within that segment.</td>
            </tr>
            <tr>
                <td><strong>Pct A / Pct B</strong></td>
                <td>The percentage of participants from Event A (or B) involved in overtaking interactions relative to their total count on that segment.</td>
            </tr>
            <tr>
                <td><strong>Co-presence A / Co-presence B</strong></td>
                <td>The number of times participants from Event A and Event B occupied the same segment simultaneously (a measure of concurrent use or congestion).</td>
            </tr>
        </tbody>
    </table>
</div>

{% endblock %}

{% block extra_scripts %}
<script>
    let flowData = {};
    let currentSort = { column: null, direction: 'asc' }; // 'asc' or 'desc' (Issue #596: Fix - moved outside DOMContentLoaded)
    
    // Load flow data on page load
    document.addEventListener('DOMContentLoaded', function() {
        initializeSorting();
        loadFlowData();
    });
    
    function loadFlowData() {
        // Get run_id and day from URL or global state
        const params = new URLSearchParams(window.location.search);
        const dayParam = params.get('day');
        const runParam = params.get('run_id');
        
        const day = (dayParam || (window.runflowDay && window.runflowDay.selected) || '').toLowerCase().trim();
        const run_id = (runParam || (window.runflowDay && window.runflowDay.run_id) || '').trim();
        
        if (!day || !run_id) {
            console.error('❌ Refusing to fetch flow data without day+run_id', {
                href: window.location.href,
                dayParam, runParam,
                runflowDay: window.runflowDay
            });
            showFlowError();
            return;
        }
        
        const apiUrl = `/api/flow/segments?run_id=${encodeURIComponent(run_id)}&day=${encodeURIComponent(day)}`;
        console.log('Loading flow data via API...', { apiUrl, day, run_id });
        
        fetch(apiUrl, { cache: 'no-store' })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                // Handle new response format with selected_day/available_days
                const flow = data.flow || data;
                flowData = flow;
                renderFlowTable(flow);
            })
            .catch(error => {
                console.error('Error loading flow data:', error);
                showFlowError();
            });
    }
    
    function renderFlowTable(flow) {
        const tbody = document.getElementById('flow-tbody');
        tbody.innerHTML = '';
        
        const segments = Object.values(flow);
        
        if (!segments || segments.length === 0) {
            tbody.innerHTML = '<tr><td colspan="7" class="placeholder">No flow data available</td></tr>';
            return;
        }
        
        // Apply sorting if column is selected
        let sortedSegments = segments;
        if (currentSort.column) {
            sortedSegments = sortSegments(segments, currentSort.column, currentSort.direction);
        } else {
            // Default sort by id
            sortedSegments = [...segments].sort((a, b) => a.id.localeCompare(b.id));
        }
        
        sortedSegments.forEach(segment => {
            const row = document.createElement('tr');
            
            // Handle null/missing values with fallback to "—"
            const eventA = segment.event_a || "—";
            const eventB = segment.event_b || "—";
            const overtakingA = segment.overtaking_a !== null && segment.overtaking_a !== undefined ? segment.overtaking_a.toFixed(0) : "—";
            const overtakingB = segment.overtaking_b !== null && segment.overtaking_b !== undefined ? segment.overtaking_b.toFixed(0) : "—";
            const pctA = segment.pct_a !== null && segment.pct_a !== undefined ? segment.pct_a.toFixed(1) + "%" : "—";
            const pctB = segment.pct_b !== null && segment.pct_b !== undefined ? segment.pct_b.toFixed(1) + "%" : "—";
            const copresenceA = segment.copresence_a !== null && segment.copresence_a !== undefined ? segment.copresence_a.toFixed(0) : "—";
            const copresenceB = segment.copresence_b !== null && segment.copresence_b !== undefined ? segment.copresence_b.toFixed(0) : "—";
            
            row.innerHTML = `
                <td>${segment.id}</td>
                <td>${segment.name}</td>
                <td class="event-pair">${eventA} / ${eventB}</td>
                <td>${segment.flow_type || 'overtake'}</td>
                <td class="numeric-pair">${overtakingA} / ${overtakingB}</td>
                <td class="numeric-pair">${pctA} / ${pctB}</td>
                <td class="numeric-pair">${copresenceA} / ${copresenceB}</td>
            `;
            
            tbody.appendChild(row);
        });
        
        // Add summary row
        const totalRow = document.createElement('tr');
        totalRow.style.fontWeight = '600';
        totalRow.style.background = '#f8f9fa';
        
        const totals = {
            overtaking_a: 0,
            overtaking_b: 0,
            copresence_a: 0,
            copresence_b: 0
        };
        
        sortedSegments.forEach(seg => {
            totals.overtaking_a += (seg.overtaking_a || 0);
            totals.overtaking_b += (seg.overtaking_b || 0);
            totals.copresence_a += (seg.copresence_a || 0);
            totals.copresence_b += (seg.copresence_b || 0);
        });
        
        totalRow.innerHTML = `
            <td>TOTAL</td>
            <td>${sortedSegments.length} segments</td>
            <td class="event-pair">— / —</td>
            <td>—</td>
            <td class="numeric-pair">${totals.overtaking_a.toFixed(0)} / ${totals.overtaking_b.toFixed(0)}</td>
            <td class="numeric-pair">— / —</td>
            <td class="numeric-pair">${totals.copresence_a.toFixed(0)} / ${totals.copresence_b.toFixed(0)}</td>
        `;
        
        tbody.appendChild(totalRow);
        
        // Update sort indicators
        updateSortIndicators();
    }
    
    function sortSegments(segments, column, direction) {
        const sorted = [...segments];
        
        sorted.sort((a, b) => {
            let aVal, bVal;
            
            switch (column) {
                case 'overtaking':
                    // Sort by sum of A + B (Issue #596)
                    const aOvertaking = (a.overtaking_a || 0) + (a.overtaking_b || 0);
                    const bOvertaking = (b.overtaking_a || 0) + (b.overtaking_b || 0);
                    aVal = aOvertaking;
                    bVal = bOvertaking;
                    break;
                case 'copresence':
                    // Sort by sum of A + B (Issue #596)
                    const aCopresence = (a.copresence_a || 0) + (a.copresence_b || 0);
                    const bCopresence = (b.copresence_a || 0) + (b.copresence_b || 0);
                    aVal = aCopresence;
                    bVal = bCopresence;
                    break;
                default:
                    return 0;
            }
            
            if (aVal < bVal) return direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return direction === 'asc' ? 1 : -1;
            return 0;
        });
        
        return sorted;
    }
    
    function initializeSorting() {
        const sortableHeaders = document.querySelectorAll('#flow-table th.sortable');
        sortableHeaders.forEach(header => {
            header.style.cursor = 'pointer';
            header.addEventListener('click', function() {
                const column = this.getAttribute('data-sort');
                if (!column) return;
                
                // Toggle sort direction if same column
                if (currentSort.column === column) {
                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort.column = column;
                    currentSort.direction = 'asc';
                }
                
                // Re-render table with new sort
                if (flowData && Object.keys(flowData).length > 0) {
                    renderFlowTable(flowData);
                }
            });
        });
    }
    
    function updateSortIndicators() {
        const sortableHeaders = document.querySelectorAll('#flow-table th.sortable');
        sortableHeaders.forEach(header => {
            const indicator = header.querySelector('.sort-indicator');
            const column = header.getAttribute('data-sort');
            
            if (indicator) {
                if (currentSort.column === column) {
                    indicator.textContent = currentSort.direction === 'asc' ? ' ▲' : ' ▼';
                    indicator.style.color = '#007bff';
                } else {
                    indicator.textContent = '';
                }
            }
        });
    }
    
    function showFlowError() {
        const tbody = document.getElementById('flow-tbody');
        tbody.innerHTML = '<tr><td colspan="7" class="placeholder">Error loading flow data</td></tr>';
    }
</script>
{% endblock %}

{% block extra_styles %}
<style>
    #flow-table th.sortable {
        cursor: pointer;
        user-select: none;
        position: relative;
    }
    
    #flow-table th.sortable:hover {
        background: #e9ecef;
    }
    
    #flow-table th.sortable .sort-indicator {
        color: #007bff;
        font-size: 0.75rem;
        margin-left: 0.25rem;
    }
    
    #flow-table {
        width: 100%;
        border-collapse: collapse;
    }
    
    /* Match base template styling for consistency with Segments table */
    #flow-table th,
    #flow-table td {
        padding: 0.875rem 1rem;  /* Match base template: px-4 py-3 equivalent */
        text-align: left;
        border-bottom: 1px solid #e0e0e0;  /* Match base template border color */
    }
    
    #flow-table th {
        background: #f8f9fa;
        font-weight: 600;
        color: #2c3e50;
    }
    
    #flow-table tbody tr:hover {
        background: #f8f9fa;
    }
    
    /* Styling for merged A/B columns */
    td.numeric-pair {
        text-align: right;
        white-space: nowrap;
    }
    
    td.event-pair {
        white-space: nowrap;
    }
    
    td.numeric-pair span.separator {
        color: #9ca3af; /* Tailwind gray-400 equivalent */
        margin: 0 2px;
    }
</style>
{% endblock %}
