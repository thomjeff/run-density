{% extends "base.html" %}

{% block title %}Flow Analysis{% endblock %}

{% block content %}
<div class="page-header">
    <h2>Temporal Flow Analysis</h2>
    {% if meta %}
    {% endif %}
</div>

<!-- Flow Overlaps -->
<div class="card">
    <h3 style="margin-bottom: 0.5rem;">Flow Overlaps</h3>
    <p id="overlap-note" style="margin-bottom: 1rem; color: #7f8c8d; font-size: 0.875rem;">
        Loading overlap summary...
    </p>
    <div class="scrollable-table-container overlap-table-container">
        <table id="overlap-table" class="table-sticky-header">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>NAME</th>
                    <th>EVENTS</th>
                    <th>OVERLAP</th>
                    <th>DURATION</th>
                    <th>PEAK</th>
                </tr>
            </thead>
            <tbody id="overlap-tbody">
                <tr>
                    <td colspan="6" class="placeholder">Loading overlap data...</td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="overlap-detail" class="overlap-detail" style="display:none;">
        <h4 style="margin: 1rem 0 0.5rem 0;">Bidirectional Overlap</h4>
        <div id="overlap-detail-meta" style="margin-bottom: 0.75rem; color: #2c3e50;"></div>
        <div id="overlap-chart" class="overlap-chart"></div>
        <div class="scrollable-table-container overlap-detail-table-container" style="margin-top: 0.75rem;">
            <table id="overlap-detail-table" class="table-sticky-header">
                <thead>
                    <tr>
                        <th>MINUTE</th>
                        <th id="overlap-col-a">A</th>
                        <th id="overlap-col-b">B</th>
                    </tr>
                </thead>
                <tbody id="overlap-detail-tbody">
                    <tr>
                        <td colspan="3" class="placeholder">Select a segment to view per-minute overlaps.</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- Flow Metrics Table -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Segment Flow Metrics</h3>
    <p style="margin-bottom: 1rem; color: #7f8c8d; font-size: 0.875rem;">
        Values are sums across all event pairs per segment from temporal flow analysis.
    </p>
    <div class="scrollable-table-container">
        <table id="flow-table" class="table-sticky-header">
            <thead>
                <tr>
                    <th></th> <!-- Expand/collapse icon -->
                    <th>ID</th>
                    <th>NAME</th>
                    <th>EVENT</th>
                    <th>FLOW TYPE</th>
                    <th>WORST ZONE</th>
                    <th class="sortable" data-sort="overtaking">OVERTAKING <span class="sort-indicator"></span></th>
                    <th>PCT</th>
                    <th class="sortable" data-sort="copresence">CO-PRESENCE <span class="sort-indicator"></span></th>
                </tr>
            </thead>
            <tbody id="flow-tbody">
                <tr>
                    <td colspan="9" class="placeholder">Loading flow data...</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Flow Reference -->
<div class="card">
    <h3 style="margin-bottom: 1rem;">Flow Reference</h3>
    <p style="margin-bottom: 1rem; color: #666; font-size: 0.9rem;">
        Definitions for key metrics in the temporal flow analysis.
    </p>
    <table>
        <thead>
            <tr>
                <th>Column</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Event A / Event B</strong></td>
                <td>The two event cohorts being compared (e.g., Full vs Half Marathon). Each pair shows interactions between participants from these events along a segment.</td>
            </tr>
            <tr>
                <td><strong>Flow Type</strong></td>
                <td>Indicates the interaction pattern between the two events:<br>
                • <em>Overtake</em>: Participants in one event pass another.<br>
                • <em>Parallel</em>: Both events move in the same direction concurrently.<br>
                • <em>Counterflow</em>: Participants move in opposite directions on the same path.</td>
            </tr>
            <tr>
                <td><strong>Overtaking A / Overtaking B</strong></td>
                <td>The number of overtake events detected where runners in Event A (or B) passed participants from the paired event within that segment.<br><br><em><strong>Note:</strong> When Event A = Event B, particularly on short segments near the start of a race, overtaking counts may be influenced by start offsets (staggered start times). Faster runners starting later can legitimately overtake slower runners who started earlier, even when average pace data is used.</em></td>
            </tr>
            <tr>
                <td><strong>Pct A / Pct B</strong></td>
                <td>The percentage of participants from Event A (or B) involved in overtaking interactions relative to their total count on that segment.</td>
            </tr>
            <tr>
                <td><strong>Co-presence A / Co-presence B</strong></td>
                <td>The number of times participants from Event A and Event B occupied the same segment simultaneously (a measure of concurrent use or congestion).<br><br><em><strong>Note:</strong> When Event A = Event B on short, early-race segments, co-presence counts can be elevated due to dense start conditions and staggered start offsets, where many participants occupy the segment simultaneously before spacing naturally increases.</em></td>
            </tr>
        </tbody>
    </table>
</div>

{% endblock %}

{% block extra_scripts %}
<script>
    let flowData = {};
    let currentSort = { column: null, direction: 'asc' }; // 'asc' or 'desc' (Issue #596: Fix - moved outside DOMContentLoaded)
    let overlapSummary = null;
    
    // Load flow data on page load
    document.addEventListener('DOMContentLoaded', function() {
        initializeSorting();
        loadFlowData();
        loadOverlapData();
    });
    
    function loadFlowData() {
        // Get run_id and day from URL or global state
        const params = new URLSearchParams(window.location.search);
        const dayParam = params.get('day');
        const runParam = params.get('run_id');
        
        const day = (dayParam || (window.runflowDay && window.runflowDay.selected) || '').toLowerCase().trim();
        const run_id = (runParam || (window.runflowDay && window.runflowDay.run_id) || '').trim();
        
        if (!day || !run_id) {
            console.error('❌ Refusing to fetch flow data without day+run_id', {
                href: window.location.href,
                dayParam, runParam,
                runflowDay: window.runflowDay
            });
            showFlowError();
            return;
        }
        
        const apiUrl = `/api/flow/segments?run_id=${encodeURIComponent(run_id)}&day=${encodeURIComponent(day)}`;
        console.log('Loading flow data via API...', { apiUrl, day, run_id });
        
        fetch(apiUrl, { cache: 'no-store' })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                // Handle new response format with selected_day/available_days
                const flow = data.flow || data;
                flowData = flow;
                renderFlowTable(flow);
            })
            .catch(error => {
                console.error('Error loading flow data:', error);
                showFlowError();
            });
    }
    
    function renderFlowTable(flow) {
        const tbody = document.getElementById('flow-tbody');
        tbody.innerHTML = '';
        
        const segments = Object.values(flow);
        
        if (!segments || segments.length === 0) {
            tbody.innerHTML = '<tr><td colspan="9" class="placeholder">No flow data available</td></tr>';
            return;
        }
        
        // Apply sorting if column is selected
        let sortedSegments = segments;
        if (currentSort.column) {
            sortedSegments = sortSegments(segments, currentSort.column, currentSort.direction);
        } else {
            // Default sort by seg_id
            sortedSegments = [...segments].sort((a, b) => (a.seg_id || '').localeCompare(b.seg_id || ''));
        }
        
        sortedSegments.forEach(segment => {
            // Issue #628: Use worst zone metrics from segment data
            const worstZone = segment.worst_zone || {};
            // Issue #628: Display only zone_index (not zone_index/zone_count)
            const worstZoneDisplay = worstZone.zone_index !== undefined ? worstZone.zone_index.toString() : "—";
            
            // Get worst zone metrics or fallback to segment metrics
            const overtakingA = worstZone.overtaking_a !== null && worstZone.overtaking_a !== undefined ? worstZone.overtaking_a : (segment.overtaking_a !== null && segment.overtaking_a !== undefined ? segment.overtaking_a : 0);
            const overtakingB = worstZone.overtaking_b !== null && worstZone.overtaking_b !== undefined ? worstZone.overtaking_b : (segment.overtaking_b !== null && segment.overtaking_b !== undefined ? segment.overtaking_b : 0);
            const copresenceA = worstZone.copresence_a !== null && worstZone.copresence_a !== undefined ? worstZone.copresence_a : (segment.copresence_a !== null && segment.copresence_a !== undefined ? segment.copresence_a : 0);
            const copresenceB = worstZone.copresence_b !== null && worstZone.copresence_b !== undefined ? worstZone.copresence_b : (segment.copresence_b !== null && segment.copresence_b !== undefined ? segment.copresence_b : 0);
            const pctA = worstZone.pct_a !== null && worstZone.pct_a !== undefined ? worstZone.pct_a : (segment.pct_a !== null && segment.pct_a !== undefined ? segment.pct_a : 0);
            const pctB = worstZone.pct_b !== null && worstZone.pct_b !== undefined ? worstZone.pct_b : (segment.pct_b !== null && segment.pct_b !== undefined ? segment.pct_b : 0);
            
            // Format display values - Issue #628: Show "0" instead of "—" for zero values
            const eventA = segment.event_a || "—";
            const eventB = segment.event_b || "—";
            const overtakingADisplay = overtakingA.toFixed(0);
            const overtakingBDisplay = overtakingB.toFixed(0);
            const pctADisplay = pctA > 0 ? pctA.toFixed(1) + "%" : "0%";
            const pctBDisplay = pctB > 0 ? pctB.toFixed(1) + "%" : "0%";
            const copresenceADisplay = copresenceA.toFixed(0);
            const copresenceBDisplay = copresenceB.toFixed(0);
            
            // Create main segment row
            const row = document.createElement('tr');
            row.className = 'segment-row';
            row.dataset.segmentKey = `${segment.seg_id}_${segment.event_a}_${segment.event_b}`;
            
            row.innerHTML = `
                <td class="expand-icon" style="cursor: pointer; text-align: center; width: 30px;">
                    <span class="expand-symbol">▶</span>
                </td>
                <td>${segment.seg_id || "—"}</td>
                <td>${segment.segment_label || segment.name || "—"}</td>
                <td class="event-pair">${eventA} / ${eventB}</td>
                <td>${segment.flow_type || 'overtake'}</td>
                <td>${worstZoneDisplay}</td>
                <td class="numeric-pair">${overtakingADisplay} / ${overtakingBDisplay}</td>
                <td class="numeric-pair">${pctADisplay} / ${pctBDisplay}</td>
                <td class="numeric-pair">${copresenceADisplay} / ${copresenceBDisplay}</td>
            `;
            
            tbody.appendChild(row);
            
            // Issue #628: Add zone drilldown row (initially hidden)
            if (segment.zones && segment.zones.length > 0) {
                const zoneRow = document.createElement('tr');
                zoneRow.className = 'zone-drilldown-row';
                zoneRow.style.display = 'none';
                zoneRow.dataset.segmentKey = `${segment.seg_id}_${segment.event_a}_${segment.event_b}`;
                
                const zoneCell = document.createElement('td');
                zoneCell.colSpan = 9;
                zoneCell.className = 'zone-drilldown-cell';
                zoneCell.style.padding = '1rem';
                zoneCell.style.backgroundColor = '#f8f9fa';
                
                // Build zone table HTML
                zoneCell.innerHTML = buildZoneTable(segment.zones, segment);
                zoneRow.appendChild(zoneCell);
                tbody.appendChild(zoneRow);
                
                // Add click handler to expand/collapse
                row.querySelector('.expand-icon').addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleZoneDrilldown(row, zoneRow);
                });
                
                // Issue #628: Initialize zone table sorting after DOM is updated
                setTimeout(() => {
                    initializeZoneTableSorting(zoneCell, segment.zones, segment);
                }, 0);
            } else {
                // No zones - disable expand
                const expandIcon = row.querySelector('.expand-icon');
                expandIcon.style.cursor = 'default';
                expandIcon.style.opacity = '0.3';
            }
        });
        
        // Update sort indicators
        updateSortIndicators();
    }
    
    function toggleZoneDrilldown(segmentRow, zoneRow) {
        const isExpanded = zoneRow.style.display !== 'none';
        const expandSymbol = segmentRow.querySelector('.expand-symbol');
        
        if (isExpanded) {
            zoneRow.style.display = 'none';
            expandSymbol.textContent = '▶';
            expandSymbol.style.transform = 'rotate(0deg)';
        } else {
            zoneRow.style.display = '';
            expandSymbol.textContent = '▼';
            expandSymbol.style.transform = 'rotate(0deg)';
        }
    }
    
    function buildZoneTable(zones, segment) {
        if (!zones || zones.length === 0) {
            return '<p style="color: #666; font-style: italic;">No zone data available for this segment.</p>';
        }
        
        // Sort zones by zone_index
        const sortedZones = [...zones].sort((a, b) => (a.zone_index || 0) - (b.zone_index || 0));
        
        let html = '<div style="margin-bottom: 1rem;"><h4 style="margin: 0 0 0.75rem 0;">Zone-Level Details</h4></div>';
        html += '<div style="overflow-x: auto;"><table id="zone-table-' + segment.seg_id + '-' + segment.event_a + '-' + segment.event_b + '" class="zone-table">';
        html += '<thead><tr>';
        html += '<th class="sortable" data-sort="zone_index">Zone <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="cp_km">Distance <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="overtaking_a">Overtaking <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="overtaken_a">Overtaken <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="copresence_a">Co-presence <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="unique_encounters">Unique Encounters <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="participants_involved">Participants <span class="sort-indicator"></span></th>';
        html += '<th class="sortable" data-sort="multi_category_runners">Multi-category <span class="sort-indicator"></span></th>';
        html += '</tr></thead><tbody>';
        
        sortedZones.forEach(zone => {
            const caption = zone.caption || {};
            const captionSummary = caption.summary || '';
            
            html += '<tr class="zone-row">';
            html += '<td><strong>' + (zone.zone_index !== undefined ? zone.zone_index : '0') + '</strong></td>';
            html += '<td>' + (zone.cp_km !== undefined ? zone.cp_km.toFixed(2) : '0.00') + '</td>';
            // Issue #628: Merge Overtaking, Overtaken, Co-Presence into A/B format
            html += '<td class="numeric-pair">' + (zone.overtaking_a !== undefined ? zone.overtaking_a : 0) + ' / ' + (zone.overtaking_b !== undefined ? zone.overtaking_b : 0) + '</td>';
            html += '<td class="numeric-pair">' + (zone.overtaken_a !== undefined ? zone.overtaken_a : 0) + ' / ' + (zone.overtaken_b !== undefined ? zone.overtaken_b : 0) + '</td>';
            html += '<td class="numeric-pair">' + (zone.copresence_a !== undefined ? zone.copresence_a : 0) + ' / ' + (zone.copresence_b !== undefined ? zone.copresence_b : 0) + '</td>';
            html += '<td class="numeric">' + (zone.unique_encounters !== undefined ? zone.unique_encounters.toLocaleString() : '0') + '</td>';
            html += '<td class="numeric">' + (zone.participants_involved !== undefined ? zone.participants_involved : 0) + '</td>';
            html += '<td class="numeric">' + (zone.multi_category_runners !== undefined ? zone.multi_category_runners : 0) + '</td>';
            html += '</tr>';
            
            // Issue #628: Add caption row below zone row
            if (captionSummary) {
                html += '<tr class="zone-caption-row">';
                html += '<td colspan="8" style="padding: 0.75rem 1rem; background: #fff; border-bottom: 1px solid #e0e0e0;">';
                html += '<div style="font-size: 0.9rem; line-height: 1.5; color: #2c3e50; font-style: italic;">' + escapeHtml(captionSummary) + '</div>';
                html += '</td>';
                html += '</tr>';
            }
        });
        
        html += '</tbody></table></div>';
        
        return html;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function sortSegments(segments, column, direction) {
        const sorted = [...segments];
        
        sorted.sort((a, b) => {
            let aVal, bVal;
            
            // Issue #628: Use worst zone metrics for sorting
            const aWorstZone = a.worst_zone || {};
            const bWorstZone = b.worst_zone || {};
            
            switch (column) {
                case 'overtaking':
                    // Sort by worst zone overtaking sum
                    const aOvertaking = (aWorstZone.overtaking_a || a.overtaking_a || 0) + (aWorstZone.overtaking_b || a.overtaking_b || 0);
                    const bOvertaking = (bWorstZone.overtaking_a || b.overtaking_a || 0) + (bWorstZone.overtaking_b || b.overtaking_b || 0);
                    aVal = aOvertaking;
                    bVal = bOvertaking;
                    break;
                case 'copresence':
                    // Sort by worst zone copresence sum
                    const aCopresence = (aWorstZone.copresence_a || a.copresence_a || 0) + (aWorstZone.copresence_b || a.copresence_b || 0);
                    const bCopresence = (bWorstZone.copresence_a || b.copresence_a || 0) + (bWorstZone.copresence_b || b.copresence_b || 0);
                    aVal = aCopresence;
                    bVal = bCopresence;
                    break;
                default:
                    return 0;
            }
            
            if (aVal < bVal) return direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return direction === 'asc' ? 1 : -1;
            return 0;
        });
        
        return sorted;
    }
    
    function initializeSorting() {
        const sortableHeaders = document.querySelectorAll('#flow-table th.sortable');
        sortableHeaders.forEach(header => {
            header.style.cursor = 'pointer';
            header.addEventListener('click', function() {
                const column = this.getAttribute('data-sort');
                if (!column) return;
                
                // Toggle sort direction if same column
                if (currentSort.column === column) {
                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort.column = column;
                    currentSort.direction = 'asc';
                }
                
                // Re-render table with new sort
                if (flowData && Object.keys(flowData).length > 0) {
                    renderFlowTable(flowData);
                }
            });
        });
    }
    
    function updateSortIndicators() {
        const sortableHeaders = document.querySelectorAll('#flow-table th.sortable');
        sortableHeaders.forEach(header => {
            const indicator = header.querySelector('.sort-indicator');
            const column = header.getAttribute('data-sort');
            
            if (indicator) {
                if (currentSort.column === column) {
                    indicator.textContent = currentSort.direction === 'asc' ? ' ▲' : ' ▼';
                    indicator.style.color = '#007bff';
                } else {
                    indicator.textContent = '';
                }
            }
        });
    }
    
    function showFlowError() {
        const tbody = document.getElementById('flow-tbody');
        tbody.innerHTML = '<tr><td colspan="9" class="placeholder">Error loading flow data</td></tr>';
    }

    function loadOverlapData() {
        const params = new URLSearchParams(window.location.search);
        const dayParam = params.get('day');
        const runParam = params.get('run_id');
        const day = (dayParam || (window.runflowDay && window.runflowDay.selected) || '').toLowerCase().trim();
        const run_id = (runParam || (window.runflowDay && window.runflowDay.run_id) || '').trim();

        if (!day || !run_id) {
            console.error('❌ Refusing to fetch overlap data without day+run_id', { day, run_id });
            showOverlapError();
            return;
        }

        const apiUrl = `/api/bidirectional/segments?run_id=${encodeURIComponent(run_id)}&day=${encodeURIComponent(day)}`;
        fetch(apiUrl, { cache: 'no-store' })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                overlapSummary = data.overlaps || { analyzed_count: 0, overlap_count: 0, segments: [] };
                renderOverlapTable(overlapSummary);
            })
            .catch(error => {
                console.error('Error loading overlap data:', error);
                showOverlapError();
            });
    }

    function renderOverlapTable(overlaps) {
        const tbody = document.getElementById('overlap-tbody');
        const note = document.getElementById('overlap-note');
        tbody.innerHTML = '';

        const analyzed = overlaps.analyzed_count || 0;
        const overlapCount = overlaps.overlap_count || 0;
        note.textContent = `${analyzed} flow segments analyzed for overlaps, ${overlapCount} segments with non-zero overlaps`;

        const segments = overlaps.segments || [];
        if (segments.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" class="placeholder">No bidirectional overlaps detected</td></tr>';
            return;
        }

        segments.forEach(segment => {
            const row = document.createElement('tr');
            row.className = 'overlap-row';
            row.dataset.segId = segment.seg_id;
            row.dataset.eventA = segment.event_a;
            row.dataset.eventB = segment.event_b;
            row.innerHTML = `
                <td>${segment.seg_id || "—"}</td>
                <td>${segment.seg_label || "—"}</td>
                <td>${segment.event_a || "—"} / ${segment.event_b || "—"}</td>
                <td>${segment.overlap_start || "—"}–${segment.overlap_end || "—"}</td>
                <td>${segment.overlap_duration_minutes || 0} min</td>
                <td>${segment.peak_concurrent_a || 0} / ${segment.peak_concurrent_b || 0}</td>
            `;
            row.addEventListener('click', function() {
                loadOverlapDetail(segment);
                highlightSelectedOverlapRow(row);
            });
            tbody.appendChild(row);
        });
    }

    function highlightSelectedOverlapRow(row) {
        document.querySelectorAll('.overlap-row').forEach(r => r.classList.remove('selected'));
        row.classList.add('selected');
    }

    function loadOverlapDetail(segment) {
        const params = new URLSearchParams(window.location.search);
        const dayParam = params.get('day');
        const runParam = params.get('run_id');
        const day = (dayParam || (window.runflowDay && window.runflowDay.selected) || '').toLowerCase().trim();
        const run_id = (runParam || (window.runflowDay && window.runflowDay.run_id) || '').trim();
        if (!day || !run_id) {
            showOverlapError();
            return;
        }

        const apiUrl = `/api/bidirectional/segment/${encodeURIComponent(segment.seg_id)}?run_id=${encodeURIComponent(run_id)}&day=${encodeURIComponent(day)}&event_a=${encodeURIComponent(segment.event_a)}&event_b=${encodeURIComponent(segment.event_b)}`;
        fetch(apiUrl, { cache: 'no-store' })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                renderOverlapDetail(data.segment, data.rows || []);
            })
            .catch(error => {
                console.error('Error loading overlap detail:', error);
                showOverlapError();
            });
    }

    function renderOverlapDetail(segment, rows) {
        const detail = document.getElementById('overlap-detail');
        const meta = document.getElementById('overlap-detail-meta');
        const chart = document.getElementById('overlap-chart');
        const tbody = document.getElementById('overlap-detail-tbody');
        const colA = document.getElementById('overlap-col-a');
        const colB = document.getElementById('overlap-col-b');

        detail.style.display = '';
        meta.innerHTML = buildOverlapMeta(segment);
        const eventKeyA = segment.event_a_label || segment.event_a;
        const eventKeyB = segment.event_b_label || segment.event_b;
        colA.textContent = `${eventKeyA} (count / entries / exits)`;
        colB.textContent = `${eventKeyB} (count / entries / exits)`;

        tbody.innerHTML = '';
        if (!rows || rows.length === 0) {
            tbody.innerHTML = '<tr><td colspan="3" class="placeholder">No per-minute overlap data available</td></tr>';
            chart.innerHTML = '';
            return;
        }

        rows.forEach(row => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${row.minute_start}–${row.minute_end}</td>
                <td class="numeric-pair">${row[`${eventKeyA}_count`]} / ${row[`${eventKeyA}_entries`]} / ${row[`${eventKeyA}_exits`]}</td>
                <td class="numeric-pair">${row[`${eventKeyB}_count`]} / ${row[`${eventKeyB}_entries`]} / ${row[`${eventKeyB}_exits`]}</td>
            `;
            tbody.appendChild(tr);
        });

        chart.innerHTML = buildOverlapChart(rows, segment, eventKeyA, eventKeyB);
    }

    function buildOverlapMeta(segment) {
        const segLabel = segment.seg_label ? ` — ${segment.seg_label}` : '';
        const rangeA = `${segment.event_a} ${segment.from_km_a}–${segment.to_km_a} km`;
        const rangeB = `${segment.event_b} ${segment.from_km_b}–${segment.to_km_b} km`;
        const title = `Bidirectional Overlap — ${segment.seg_id}${segLabel} (${rangeA}, ${rangeB})`;
        const timeRange = `${segment.overlap_start}–${segment.overlap_end}`;
        return `<div class="overlap-title">${escapeHtml(title)}</div><div class="overlap-time">${escapeHtml(timeRange)}</div>`;
    }

    function buildOverlapChart(rows, segment, eventKeyA, eventKeyB) {
        const width = 1050;
        const height = 210;
        const padding = 39;
        const eventA = segment.event_a;
        const eventB = segment.event_b;
        const countsA = rows.map(r => r[`${eventKeyA}_count`] || 0);
        const countsB = rows.map(r => r[`${eventKeyB}_count`] || 0);
        const overlapCounts = countsA.map((val, idx) => Math.min(val, countsB[idx]));
        const maxCount = Math.max(1, ...countsA, ...countsB);
        const xStep = rows.length > 1 ? (width - padding * 2) / (rows.length - 1) : 0;
        const axisY = height - padding;
        const axisX = padding;
        const labelY = height - 12;

        const points = (counts, color) => {
            const path = counts.map((val, idx) => {
                const x = padding + idx * xStep;
                const y = height - padding - (val / maxCount) * (height - padding * 2);
                return `${idx === 0 ? 'M' : 'L'}${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');
            return `<path d="${path}" fill="none" stroke="${color}" stroke-width="2" />`;
        };

        const area = (counts, color) => {
            const top = counts.map((val, idx) => {
                const x = padding + idx * xStep;
                const y = height - padding - (val / maxCount) * (height - padding * 2);
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            });
            const bottom = counts.map((_, idx) => {
                const x = padding + (counts.length - 1 - idx) * xStep;
                return `${x.toFixed(1)},${axisY.toFixed(1)}`;
            });
            const path = `M${top.join(' L')} L${bottom.join(' L')} Z`;
            return `<path d="${path}" fill="${color}" opacity="0.25" />`;
        };

        const startLabel = rows[0] ? rows[0].minute_start : '';
        const totalSpan = rows.length - 1;
        const midIndex = Math.floor(totalSpan / 2);
        const q1Index = Math.floor(totalSpan / 4);
        const q3Index = Math.floor((totalSpan * 3) / 4);
        const midLabel = rows[midIndex] ? rows[midIndex].minute_start : '';
        const q1Label = rows[q1Index] ? rows[q1Index].minute_start : '';
        const q3Label = rows[q3Index] ? rows[q3Index].minute_start : '';
        const endLabel = rows[rows.length - 1] ? rows[rows.length - 1].minute_end : '';
        const xStart = padding;
        const xQ1 = padding + q1Index * xStep;
        const xMid = padding + midIndex * xStep;
        const xQ3 = padding + q3Index * xStep;
        const xEnd = padding + totalSpan * xStep;

        return `
            <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                <rect x="0" y="0" width="${width}" height="${height}" fill="#fff" />
                <line x1="${axisX}" y1="${axisY}" x2="${width - padding}" y2="${axisY}" stroke="#e0e0e0" />
                <line x1="${axisX}" y1="${padding}" x2="${axisX}" y2="${axisY}" stroke="#e0e0e0" />
                ${area(overlapCounts, '#9ec5fe')}
                ${points(countsA, '#1f77b4')}
                ${points(countsB, '#ff7f0e')}
                <text x="${axisX}" y="${padding - 8}" font-size="10" fill="#555">Concurrent runners</text>
                <text x="${axisX + 160}" y="${padding - 8}" font-size="10" fill="#1f77b4">${eventKeyA} concurrent</text>
                <text x="${axisX + 320}" y="${padding - 8}" font-size="10" fill="#ff7f0e">${eventKeyB} concurrent</text>
                <text x="${axisX + 500}" y="${padding - 8}" font-size="10" fill="#4c7bd9">Overlap</text>
                <line x1="${xStart}" y1="${axisY}" x2="${xStart}" y2="${axisY + 4}" stroke="#9ca3af" />
                <line x1="${xQ1}" y1="${axisY}" x2="${xQ1}" y2="${axisY + 4}" stroke="#9ca3af" />
                <line x1="${xMid}" y1="${axisY}" x2="${xMid}" y2="${axisY + 4}" stroke="#9ca3af" />
                <line x1="${xQ3}" y1="${axisY}" x2="${xQ3}" y2="${axisY + 4}" stroke="#9ca3af" />
                <line x1="${xEnd}" y1="${axisY}" x2="${xEnd}" y2="${axisY + 4}" stroke="#9ca3af" />
                <text x="${xStart - 8}" y="${labelY}" font-size="10" fill="#555">${startLabel}</text>
                <text x="${xQ1 - 8}" y="${labelY}" font-size="10" fill="#555">${q1Label}</text>
                <text x="${xMid - 8}" y="${labelY}" font-size="10" fill="#555">${midLabel}</text>
                <text x="${xQ3 - 8}" y="${labelY}" font-size="10" fill="#555">${q3Label}</text>
                <text x="${xEnd - 8}" y="${labelY}" font-size="10" fill="#555">${endLabel}</text>
            </svg>
        `;
    }

    function showOverlapError() {
        const tbody = document.getElementById('overlap-tbody');
        const note = document.getElementById('overlap-note');
        tbody.innerHTML = '<tr><td colspan="6" class="placeholder">Error loading overlap data</td></tr>';
        note.textContent = 'Bidirectional overlap data unavailable';
    }
</script>
{% endblock %}

{% block extra_styles %}
<style>
    #flow-table th.sortable {
        cursor: pointer;
        user-select: none;
        position: relative;
    }
    
    #flow-table th.sortable:hover {
        background: #e9ecef;
    }
    
    #flow-table th.sortable .sort-indicator {
        color: #007bff;
        font-size: 0.75rem;
        margin-left: 0.25rem;
    }
    
    #flow-table {
        width: 100%;
        border-collapse: collapse;
    }
    
    /* Match base template styling for consistency with Segments table */
    #flow-table th,
    #flow-table td {
        padding: 0.875rem 1rem;  /* Match base template: px-4 py-3 equivalent */
        text-align: left;
        border-bottom: 1px solid #e0e0e0;  /* Match base template border color */
    }
    
    #flow-table th {
        background: #f8f9fa;
        font-weight: 600;
        color: #2c3e50;
    }
    
    #flow-table tbody tr:hover {
        background: #f8f9fa;
    }
    
    /* Styling for merged A/B columns */
    td.numeric-pair {
        text-align: right;
        white-space: nowrap;
    }
    
    td.event-pair {
        white-space: nowrap;
    }
    
    td.numeric-pair span.separator {
        color: #9ca3af; /* Tailwind gray-400 equivalent */
        margin: 0 2px;
    }
    
    /* Issue #628: Accordion styling for zone drilldown */
    .expand-icon {
        user-select: none;
        transition: transform 0.2s;
    }
    
    .expand-icon:hover {
        color: #007bff;
    }
    
    .expand-symbol {
        display: inline-block;
        transition: transform 0.2s;
    }
    
    .segment-row {
        cursor: pointer;
    }
    
    .segment-row:hover {
        background: #f8f9fa;
    }
    
    .zone-drilldown-row {
        background: #f8f9fa;
    }
    
    .zone-drilldown-cell {
        padding: 1rem !important;
    }
    
    .zone-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
    }
    
    .zone-table th {
        background: #e9ecef;
        font-weight: 600;
        padding: 0.5rem 0.75rem;
        text-align: left;
        border-bottom: 2px solid #dee2e6;
    }
    
    .zone-table th.sortable {
        cursor: pointer;
        user-select: none;
    }
    
    .zone-table th.sortable:hover {
        background: #dee2e6;
    }
    
    .zone-table td {
        padding: 0.5rem 0.75rem;
        border-bottom: 1px solid #e0e0e0;
    }
    
    .zone-table tbody tr.zone-row:hover {
        background: #fff;
    }
    
    .zone-table td.numeric {
        text-align: right;
    }
    
    .zone-caption-row td {
        font-style: italic;
        color: #495057;
        padding: 0.75rem 1rem;
    }

    #overlap-table th,
    #overlap-table td,
    #overlap-detail-table th,
    #overlap-detail-table td {
        padding: 0.75rem 1rem;
        text-align: left;
        border-bottom: 1px solid #e0e0e0;
    }

    #overlap-table th,
    #overlap-detail-table th {
        background: #f8f9fa;
        font-weight: 600;
        color: #2c3e50;
    }

    .overlap-row:hover {
        background: #f8f9fa;
        cursor: pointer;
    }

    .overlap-row.selected {
        background: #eef5ff;
    }

    .overlap-chart {
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        padding: 0.5rem;
        background: #fff;
    }

    .overlap-title {
        font-weight: 600;
        margin-bottom: 0.25rem;
    }

    .overlap-time {
        color: #6b7280;
        font-size: 0.9rem;
    }

.overlap-table-container {
    max-height: 220px;
    overflow-y: auto;
}

.overlap-detail-table-container {
    max-height: 200px;
    overflow-y: auto;
}
    
</style>
{% endblock %}
