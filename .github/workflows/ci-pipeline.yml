name: CI Pipeline

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened]

jobs:
  # Part 1: Build & Deploy (Docker ‚Üí Artifact Registry ‚Üí Cloud Run)
  build-deploy:
    name: "1Ô∏è‚É£ Build & Deploy (Docker ‚Üí Artifacts)"
    runs-on: ubuntu-latest
    # Skip deployment for PR events to prevent race conditions with merge
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      id-token: write   # WIF required

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Auth (WIF)
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account:         ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: "Resolve parameters & configure Docker"
        id: params
        env:
          REGION:     ${{ secrets.GCP_REGION }}
          PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          SERVICE:    ${{ secrets.GCP_SERVICE }}
          REPO_SEC:   ${{ secrets.GCP_AR_REPO }}   # may be empty
        run: |
          set -euo pipefail
          REPO="${REPO_SEC:-run}"   # default to 'run' if secret is empty
          echo "REGION=${REGION}"       | tee -a "$GITHUB_OUTPUT"
          echo "PROJECT_ID=${PROJECT_ID}" | tee -a "$GITHUB_OUTPUT"
          echo "SERVICE=${SERVICE}"     | tee -a "$GITHUB_OUTPUT"
          echo "REPO=${REPO}"           | tee -a "$GITHUB_OUTPUT"
          gcloud auth configure-docker "${REGION}-docker.pkg.dev" --quiet

      - name: "Build & Push image (Docker ‚Üí Artifact Registry)"
        env:
          REGION:     ${{ steps.params.outputs.REGION }}
          PROJECT_ID: ${{ steps.params.outputs.PROJECT_ID }}
          SERVICE:    ${{ steps.params.outputs.SERVICE }}
          REPO:       ${{ steps.params.outputs.REPO }}
          SHA:        ${{ github.sha }}
        run: |
          set -euo pipefail
          DOMAIN="${REGION}-docker.pkg.dev"
          IMAGE="${DOMAIN}/${PROJECT_ID}/${REPO}/${SERVICE}:${SHA}"
          echo "Building IMAGE=${IMAGE}"
          docker build -t "${IMAGE}" .
          docker push "${IMAGE}"
          echo "image=${IMAGE}" >> "$GITHUB_OUTPUT"

      - name: "Deploy to Cloud Run (latest)"
        env:
          REGION:     ${{ steps.params.outputs.REGION }}
          PROJECT_ID: ${{ steps.params.outputs.PROJECT_ID }}
          SERVICE:    ${{ steps.params.outputs.SERVICE }}
          REPO:       ${{ steps.params.outputs.REPO }}
          SHA:        ${{ github.sha }}
        run: |
          set -euo pipefail
          DOMAIN="${REGION}-docker.pkg.dev"
          IMAGE="${DOMAIN}/${PROJECT_ID}/${REPO}/${SERVICE}:${SHA}"
          echo "Deploying IMAGE=${IMAGE}"
          gcloud run deploy "${SERVICE}" \
            --project "${PROJECT_ID}" \
            --region "${REGION}" \
            --image  "${IMAGE}" \
            --platform managed \
            --allow-unauthenticated \
            --memory=3Gi --cpu=2 \
            --min-instances=0 --max-instances=3 \
            --timeout=600 --quiet

      - name: "Redirect Traffic to Latest Revision"
        env:
          REGION:     ${{ steps.params.outputs.REGION }}
          PROJECT_ID: ${{ steps.params.outputs.PROJECT_ID }}
          SERVICE:    ${{ steps.params.outputs.SERVICE }}
        run: |
          set -euo pipefail
          echo "Redirecting 100% traffic to latest revision..."
          
          # Get the latest revision name
          LATEST_REVISION=$(gcloud run revisions list \
            --service="${SERVICE}" \
            --project="${PROJECT_ID}" \
            --region="${REGION}" \
            --sort-by="~metadata.creationTimestamp" \
            --limit=1 \
            --format="value(metadata.name)")
          
          echo "Latest revision: ${LATEST_REVISION}"
          
          # Redirect 100% traffic to latest revision
          gcloud run services update-traffic "${SERVICE}" \
            --project="${PROJECT_ID}" \
            --region="${REGION}" \
            --to-revisions="${LATEST_REVISION}=100" \
            --quiet
          
          echo "‚úÖ Traffic redirected to ${LATEST_REVISION}"

  # Part 2: E2E Validation (Validate deployment with e2e.py)
  e2e-validation:
    name: "2Ô∏è‚É£ E2E (Density/Flow)"
    runs-on: ubuntu-latest
    needs: build-deploy
    # Skip E2E validation for PR events (only needed for main branch)
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run E2E Tests
      run: |
        echo "=== Running E2E Tests for Deployment Validation ==="
        echo "Testing Cloud Run deployment with e2e.py"
        python e2e.py --cloud

  # Part 3: E2E Bin Dataset Generation and Validation
  bin-dataset-validation:
    name: "3Ô∏è‚É£ E2E (Bin Datasets)"
    runs-on: ubuntu-latest
    needs: e2e-validation
    # Skip bin validation for PR events (only needed for main branch)
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      id-token: write   # WIF required for GCS access
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Auth (WIF)
      id: auth
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
        service_account:         ${{ secrets.GCP_SERVICE_ACCOUNT }}
    
    - name: Setup gcloud
      uses: google-github-actions/setup-gcloud@v2
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Enable Bin Dataset Environment
      run: |
        echo "=== Configuring Bin Dataset Validation Environment ==="
        echo "ENABLE_BIN_DATASET=true" >> $GITHUB_ENV
        echo "BIN_MAX_FEATURES=10000" >> $GITHUB_ENV
        echo "DEFAULT_BIN_TIME_WINDOW_SECONDS=60" >> $GITHUB_ENV
        echo "DEFAULT_BIN_SIZE_KM=0.1" >> $GITHUB_ENV
        echo "MAX_BIN_GENERATION_TIME_SECONDS=120" >> $GITHUB_ENV
    
    - name: Run E2E Tests with Bin Generation
      run: |
        echo "=== Running E2E Tests with Bin Dataset Generation ==="
        echo "Testing Cloud Run deployment with bin generation enabled"
        echo "Environment: ENABLE_BIN_DATASET=true"
        
        # Test basic endpoints first
        python e2e.py --cloud
        
        echo ""
        echo "=== Testing Bin Dataset Generation Specifically ==="
        
        # Test density report with bin generation explicitly enabled
        RESPONSE=$(curl -X POST "https://run-density-ln4r3sfkha-uc.a.run.app/api/density-report" \
          -H "Content-Type: application/json" \
          -d '{
            "paceCsv": "data/runners.csv",
            "densityCsv": "data/segments.csv", 
            "startTimes": {"Full": 420, "10K": 440, "Half": 460},
            "enable_bin_dataset": true
          }' \
          --max-time 300 \
          --write-out "HTTPSTATUS:%{http_code}" \
          --silent)
        
        HTTP_CODE=$(echo "$RESPONSE" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
        RESPONSE_BODY=$(echo "$RESPONSE" | sed 's/HTTPSTATUS:[0-9]*$//')
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "‚úÖ Bin Dataset Generation: OK"
          echo "Response indicates bin generation was triggered"
        else
          echo "‚ùå Bin Dataset Generation Failed: HTTP $HTTP_CODE"
          echo "Response: $RESPONSE_BODY"
          exit 1
        fi
    
    - name: Verify Bin Artifacts Generated
      run: |
        echo "=== Verifying Bin Artifacts in GCS ==="
        REPORT_DATE=$(date +%Y-%m-%d)
        echo "Checking for bin artifacts in gs://run-density-reports/$REPORT_DATE/"
        
        # Check for bin artifacts
        if gsutil ls gs://run-density-reports/$REPORT_DATE/bins.geojson.gz; then
          echo "‚úÖ Found bins.geojson.gz"
          GEOJSON_SIZE=$(gsutil ls -l gs://run-density-reports/$REPORT_DATE/bins.geojson.gz | awk '{print $1}')
          echo "‚úÖ Size: $GEOJSON_SIZE bytes"
        else
          echo "‚ùå Missing bins.geojson.gz"
          exit 1
        fi
        
        if gsutil ls gs://run-density-reports/$REPORT_DATE/bins.parquet; then
          echo "‚úÖ Found bins.parquet"
          PARQUET_SIZE=$(gsutil ls -l gs://run-density-reports/$REPORT_DATE/bins.parquet | awk '{print $1}')
          echo "‚úÖ Size: $PARQUET_SIZE bytes"
        else
          echo "‚ùå Missing bins.parquet"
          exit 1
        fi
    
    - name: Validate Bin Dataset Quality
      run: |
        echo "=== Bin Dataset Quality Validation ==="
        REPORT_DATE=$(date +%Y-%m-%d)
        
        # Download artifacts for validation (need both geojson.gz and parquet)
        mkdir -p ./validation_temp/$REPORT_DATE
        gsutil cp gs://run-density-reports/$REPORT_DATE/bins.geojson.gz ./validation_temp/$REPORT_DATE/
        gsutil cp gs://run-density-reports/$REPORT_DATE/bins.parquet ./validation_temp/$REPORT_DATE/
        gsutil cp gs://run-density-reports/$REPORT_DATE/map_data_*.json ./validation_temp/$REPORT_DATE/ || echo "Map data will be checked separately"
        
        # Run validation using existing tools
        python scripts/validation/verify_bins.py --reports-dir ./validation_temp
        
        echo "‚úÖ Bin dataset quality validation completed"

  # Part 4: Automated Release (GitHub release creation)
  automated-release:
    name: "4Ô∏è‚É£ Automated Release"
    runs-on: ubuntu-latest
    needs: [build-deploy, e2e-validation, bin-dataset-validation]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Check version consistency
      id: version-check
      run: |
        echo "=== Version Consistency Check ==="
        
        # Get versions using Python
        CODE_VERSION=$(python -c "from app.version import get_current_version; print(get_current_version())")
        GIT_TAG=$(python -c "from app.version import get_latest_git_tag; print(get_latest_git_tag())")
        
        echo "Current version in code: $CODE_VERSION"
        echo "Latest git tag: $GIT_TAG"
        
        # Check consistency and set outputs
        if [ "$CODE_VERSION" = "$GIT_TAG" ]; then
            echo "‚úÖ Version consistency check passed!"
            echo "consistent=true" >> $GITHUB_OUTPUT
            echo "version=$CODE_VERSION" >> $GITHUB_OUTPUT
        else
            echo "‚ö†Ô∏è  Version mismatch detected - will auto-fix"
            echo "consistent=false" >> $GITHUB_OUTPUT
            echo "code_version=$CODE_VERSION" >> $GITHUB_OUTPUT
            echo "git_tag=$GIT_TAG" >> $GITHUB_OUTPUT
        fi
    
    - name: Auto-fix version mismatch
      if: steps.version-check.outputs.consistent == 'false'
      run: |
        echo "=== Auto-fixing Version Mismatch ==="
        GIT_TAG="${{ steps.version-check.outputs.git_tag }}"
        echo "Updating code version to match git tag: $GIT_TAG"
        
        python -c "
        from app.version import update_version_in_code
        import sys
        
        git_tag = '$GIT_TAG'
        if update_version_in_code(git_tag):
            print(f'‚úÖ Updated code version to {git_tag}')
        else:
            print(f'‚ùå Failed to update code version to {git_tag}')
            sys.exit(1)
        "
    
    - name: Commit version fix
      if: steps.version-check.outputs.consistent == 'false'
      run: |
        echo "=== Committing Version Fix ==="
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        git add app/main.py
        git commit -m "Auto-fix version consistency: Update code version to match git tag
        
        - Automated fix for Issue #150: Recurring CI Version Consistency Failures
        - Code version now matches latest git tag
        - This prevents CI failures due to version mismatches"
        
        git push origin main
        echo "‚úÖ Version fix committed and pushed"
    
    - name: Verify final version consistency
      run: |
        echo "=== Final Version Consistency Verification ==="
        python -c "
        from app.version import validate_version_consistency, get_current_version, get_latest_git_tag
        import sys
        
        print('Final verification:')
        print('Current version in code:', get_current_version())
        print('Latest git tag:', get_latest_git_tag())
        
        if validate_version_consistency():
            print('‚úÖ Final version consistency check passed!')
        else:
            print('‚ùå Final version consistency check failed!')
            sys.exit(1)
        "
    
    - name: Get final version for release
      id: version
      run: |
        python -c "
        from app.version import get_current_version
        version = get_current_version()
        print(f'version={version}')
        " >> $GITHUB_OUTPUT
    
    - name: Check if release already exists
      id: check-release
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "Checking if release ${{ steps.version.outputs.version }} already exists..."
        if gh release view ${{ steps.version.outputs.version }} >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Release ${{ steps.version.outputs.version }} already exists - will skip creation"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "‚úÖ Release ${{ steps.version.outputs.version }} does not exist - will create"
        fi
    
    - name: Skip Release Creation (Already Exists)
      if: steps.check-release.outputs.exists == 'true'
      run: |
        echo "=== Release Already Exists ==="
        echo "‚úÖ Release ${{ steps.version.outputs.version }} already exists"
        echo "Skipping release creation to avoid duplicates"
        echo "This is expected behavior when multiple pushes occur with the same version"
    
    - name: Create GitHub Release
      if: steps.check-release.outputs.exists == 'false'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "=== Creating GitHub Release ==="
        echo "Release check result: ${{ steps.check-release.outputs.exists }}"
        echo "Creating release: ${{ steps.version.outputs.version }}"
        
        # Double-check release doesn't exist before creating
        if gh release view ${{ steps.version.outputs.version }} >/dev/null 2>&1; then
          echo "‚ùå ERROR: Release ${{ steps.version.outputs.version }} already exists! This should not happen."
          echo "Skipping release creation to avoid duplicate."
          exit 0
        fi
        
        gh release create ${{ steps.version.outputs.version }} \
          --title "Release ${{ steps.version.outputs.version }}" \
          --notes "## üöÄ Automated Release ${{ steps.version.outputs.version }}

        This release was created automatically from the simplified CI pipeline.

        ### Validation
        - ‚úÖ Build & Deploy completed successfully
        - ‚úÖ E2E validation passed (e2e.py --cloud)
        - ‚úÖ Version consistency validated
        - ‚úÖ Quality gate enforced before release

        ### Workflow
        Deploy ‚Üí E2E Test ‚Üí Release (only if E2E passes)

        ### Next Steps
        1. Review the release notes
        2. Verify production deployment is working
        3. Monitor Cloud Run performance" \
          --verify-tag
    
    - name: Upload Release Assets
      if: steps.check-release.outputs.exists == 'false'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "=== Uploading Release Assets ==="
        # Find the latest reports
        if [ -d "reports" ]; then
          LATEST_DATE=$(ls -1 reports/ | sort | tail -1)
          if [ -n "$LATEST_DATE" ] && [ -d "reports/$LATEST_DATE" ]; then
            echo "Uploading reports from reports/$LATEST_DATE"
            gh release upload ${{ steps.version.outputs.version }} reports/$LATEST_DATE/*.md reports/$LATEST_DATE/*.csv
          fi
        fi
        
        # Upload E2E test results if available
        if [ -d "e2e_tests" ]; then
          LATEST_E2E_DATE=$(ls -1 e2e_tests/ | sort | tail -1)
          if [ -n "$LATEST_E2E_DATE" ] && [ -d "e2e_tests/$LATEST_E2E_DATE" ]; then
            echo "Uploading E2E results from e2e_tests/$LATEST_E2E_DATE"
            gh release upload ${{ steps.version.outputs.version }} e2e_tests/$LATEST_E2E_DATE/*.md
          fi
        fi

