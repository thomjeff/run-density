name: CI Pipeline

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened]

jobs:
  # Part 1: Build & Deploy (Docker → Artifact Registry → Cloud Run)
  build-deploy:
    name: "1️⃣ Build & Deploy (Docker → Artifacts)"
    runs-on: ubuntu-latest
    # Skip deployment for PR events to prevent race conditions with merge
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      id-token: write   # WIF required

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Auth (WIF)
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account:         ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: "Resolve parameters & configure Docker"
        id: params
        env:
          REGION:     ${{ secrets.GCP_REGION }}
          PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          SERVICE:    ${{ secrets.GCP_SERVICE }}
          REPO_SEC:   ${{ secrets.GCP_AR_REPO }}   # may be empty
        run: |
          set -euo pipefail
          REPO="${REPO_SEC:-run}"   # default to 'run' if secret is empty
          echo "REGION=${REGION}"       | tee -a "$GITHUB_OUTPUT"
          echo "PROJECT_ID=${PROJECT_ID}" | tee -a "$GITHUB_OUTPUT"
          echo "SERVICE=${SERVICE}"     | tee -a "$GITHUB_OUTPUT"
          echo "REPO=${REPO}"           | tee -a "$GITHUB_OUTPUT"
          gcloud auth configure-docker "${REGION}-docker.pkg.dev" --quiet

      - name: "Build & Push image (Docker → Artifact Registry)"
        env:
          REGION:     ${{ steps.params.outputs.REGION }}
          PROJECT_ID: ${{ steps.params.outputs.PROJECT_ID }}
          SERVICE:    ${{ steps.params.outputs.SERVICE }}
          REPO:       ${{ steps.params.outputs.REPO }}
          SHA:        ${{ github.sha }}
        run: |
          set -euo pipefail
          DOMAIN="${REGION}-docker.pkg.dev"
          IMAGE="${DOMAIN}/${PROJECT_ID}/${REPO}/${SERVICE}:${SHA}"
          echo "Building IMAGE=${IMAGE}"
          docker build -t "${IMAGE}" .
          docker push "${IMAGE}"
          echo "image=${IMAGE}" >> "$GITHUB_OUTPUT"

      - name: "Deploy to Cloud Run (latest)"
        env:
          REGION:     ${{ steps.params.outputs.REGION }}
          PROJECT_ID: ${{ steps.params.outputs.PROJECT_ID }}
          SERVICE:    ${{ steps.params.outputs.SERVICE }}
          REPO:       ${{ steps.params.outputs.REPO }}
          SHA:        ${{ github.sha }}
        run: |
          set -euo pipefail
          DOMAIN="${REGION}-docker.pkg.dev"
          IMAGE="${DOMAIN}/${PROJECT_ID}/${REPO}/${SERVICE}:${SHA}"
          echo "Deploying IMAGE=${IMAGE}"
          gcloud run deploy "${SERVICE}" \
            --project "${PROJECT_ID}" \
            --region "${REGION}" \
            --image  "${IMAGE}" \
            --platform managed \
            --allow-unauthenticated \
            --memory=2Gi --cpu=2 \
            --min-instances=0 --max-instances=3 \
            --timeout=300 --quiet

      - name: "Redirect Traffic to Latest Revision"
        env:
          REGION:     ${{ steps.params.outputs.REGION }}
          PROJECT_ID: ${{ steps.params.outputs.PROJECT_ID }}
          SERVICE:    ${{ steps.params.outputs.SERVICE }}
        run: |
          set -euo pipefail
          echo "Redirecting 100% traffic to latest revision..."
          
          # Get the latest revision name
          LATEST_REVISION=$(gcloud run revisions list \
            --service="${SERVICE}" \
            --project="${PROJECT_ID}" \
            --region="${REGION}" \
            --sort-by="~metadata.creationTimestamp" \
            --limit=1 \
            --format="value(metadata.name)")
          
          echo "Latest revision: ${LATEST_REVISION}"
          
          # Redirect 100% traffic to latest revision
          gcloud run services update-traffic "${SERVICE}" \
            --project="${PROJECT_ID}" \
            --region="${REGION}" \
            --to-revisions="${LATEST_REVISION}=100" \
            --quiet
          
          echo "✅ Traffic redirected to ${LATEST_REVISION}"

  # Part 2: E2E Validation (Validate deployment with e2e.py)
  e2e-validation:
    name: "2️⃣ E2E Validation"
    runs-on: ubuntu-latest
    needs: build-deploy
    # Skip E2E validation for PR events (only needed for main branch)
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run E2E Tests
      run: |
        echo "=== Running E2E Tests for Deployment Validation ==="
        echo "Testing Cloud Run deployment with e2e.py"
        python e2e.py --cloud

  # Part 3: Automated Release (GitHub release creation)
  automated-release:
    name: "3️⃣ Automated Release"
    runs-on: ubuntu-latest
    needs: [build-deploy, e2e-validation]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Check version consistency
      id: version-check
      run: |
        echo "=== Version Consistency Check ==="
        
        # Get versions using Python
        CODE_VERSION=$(python -c "from app.version import get_current_version; print(get_current_version())")
        GIT_TAG=$(python -c "from app.version import get_latest_git_tag; print(get_latest_git_tag())")
        
        echo "Current version in code: $CODE_VERSION"
        echo "Latest git tag: $GIT_TAG"
        
        # Check consistency and set outputs
        if [ "$CODE_VERSION" = "$GIT_TAG" ]; then
            echo "✅ Version consistency check passed!"
            echo "consistent=true" >> $GITHUB_OUTPUT
            echo "version=$CODE_VERSION" >> $GITHUB_OUTPUT
        else
            echo "⚠️  Version mismatch detected - will auto-fix"
            echo "consistent=false" >> $GITHUB_OUTPUT
            echo "code_version=$CODE_VERSION" >> $GITHUB_OUTPUT
            echo "git_tag=$GIT_TAG" >> $GITHUB_OUTPUT
        fi
    
    - name: Auto-fix version mismatch
      if: steps.version-check.outputs.consistent == 'false'
      run: |
        echo "=== Auto-fixing Version Mismatch ==="
        GIT_TAG="${{ steps.version-check.outputs.git_tag }}"
        echo "Updating code version to match git tag: $GIT_TAG"
        
        python -c "
        from app.version import update_version_in_code
        import sys
        
        git_tag = '$GIT_TAG'
        if update_version_in_code(git_tag):
            print(f'✅ Updated code version to {git_tag}')
        else:
            print(f'❌ Failed to update code version to {git_tag}')
            sys.exit(1)
        "
    
    - name: Commit version fix
      if: steps.version-check.outputs.consistent == 'false'
      run: |
        echo "=== Committing Version Fix ==="
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        git add app/main.py
        git commit -m "Auto-fix version consistency: Update code version to match git tag
        
        - Automated fix for Issue #150: Recurring CI Version Consistency Failures
        - Code version now matches latest git tag
        - This prevents CI failures due to version mismatches"
        
        git push origin main
        echo "✅ Version fix committed and pushed"
    
    - name: Verify final version consistency
      run: |
        echo "=== Final Version Consistency Verification ==="
        python -c "
        from app.version import validate_version_consistency, get_current_version, get_latest_git_tag
        import sys
        
        print('Final verification:')
        print('Current version in code:', get_current_version())
        print('Latest git tag:', get_latest_git_tag())
        
        if validate_version_consistency():
            print('✅ Final version consistency check passed!')
        else:
            print('❌ Final version consistency check failed!')
            sys.exit(1)
        "
    
    - name: Get final version for release
      id: version
      run: |
        python -c "
        from app.version import get_current_version
        version = get_current_version()
        print(f'version={version}')
        " >> $GITHUB_OUTPUT
    
    - name: Check if release already exists
      id: check-release
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "Checking if release ${{ steps.version.outputs.version }} already exists..."
        if gh release view ${{ steps.version.outputs.version }} >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "✅ Release ${{ steps.version.outputs.version }} already exists - will skip creation"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "✅ Release ${{ steps.version.outputs.version }} does not exist - will create"
        fi
    
    - name: Skip Release Creation (Already Exists)
      if: steps.check-release.outputs.exists == 'true'
      run: |
        echo "=== Release Already Exists ==="
        echo "✅ Release ${{ steps.version.outputs.version }} already exists"
        echo "Skipping release creation to avoid duplicates"
        echo "This is expected behavior when multiple pushes occur with the same version"
    
    - name: Create GitHub Release
      if: steps.check-release.outputs.exists == 'false'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "=== Creating GitHub Release ==="
        echo "Release check result: ${{ steps.check-release.outputs.exists }}"
        echo "Creating release: ${{ steps.version.outputs.version }}"
        
        # Double-check release doesn't exist before creating
        if gh release view ${{ steps.version.outputs.version }} >/dev/null 2>&1; then
          echo "❌ ERROR: Release ${{ steps.version.outputs.version }} already exists! This should not happen."
          echo "Skipping release creation to avoid duplicate."
          exit 0
        fi
        
        gh release create ${{ steps.version.outputs.version }} \
          --title "Release ${{ steps.version.outputs.version }}" \
          --notes "## 🚀 Automated Release ${{ steps.version.outputs.version }}

        This release was created automatically from the simplified CI pipeline.

        ### Validation
        - ✅ Build & Deploy completed successfully
        - ✅ E2E validation passed (e2e.py --cloud)
        - ✅ Version consistency validated
        - ✅ Quality gate enforced before release

        ### Workflow
        Deploy → E2E Test → Release (only if E2E passes)

        ### Next Steps
        1. Review the release notes
        2. Verify production deployment is working
        3. Monitor Cloud Run performance" \
          --verify-tag
    
    - name: Upload Release Assets
      if: steps.check-release.outputs.exists == 'false'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "=== Uploading Release Assets ==="
        # Find the latest reports
        if [ -d "reports" ]; then
          LATEST_DATE=$(ls -1 reports/ | sort | tail -1)
          if [ -n "$LATEST_DATE" ] && [ -d "reports/$LATEST_DATE" ]; then
            echo "Uploading reports from reports/$LATEST_DATE"
            gh release upload ${{ steps.version.outputs.version }} reports/$LATEST_DATE/*.md reports/$LATEST_DATE/*.csv
          fi
        fi
        
        # Upload E2E test results if available
        if [ -d "e2e_tests" ]; then
          LATEST_E2E_DATE=$(ls -1 e2e_tests/ | sort | tail -1)
          if [ -n "$LATEST_E2E_DATE" ] && [ -d "e2e_tests/$LATEST_E2E_DATE" ]; then
            echo "Uploading E2E results from e2e_tests/$LATEST_E2E_DATE"
            gh release upload ${{ steps.version.outputs.version }} e2e_tests/$LATEST_E2E_DATE/*.md
          fi
        fi

